{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport Constants from 'expo-constants';\nimport { UnavailabilityError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport ExpoGoogleSignIn from \"./ExpoGoogleSignIn\";\nimport GoogleUser from \"./GoogleUser\";\nexport var {\n  ERRORS,\n  SCOPES,\n  TYPES\n} = ExpoGoogleSignIn;\nvar DEFAULT_SCOPES = [SCOPES.PROFILE, SCOPES.EMAIL];\n\nvar _initialization;\n\nvar _options;\n\nvar _currentUser = null;\nvar _isClientUsageEnabled = false;\n\nfunction setCurrentUser(currentUser) {\n  _currentUser = currentUser;\n  return _currentUser;\n}\n\nfunction validateOptions(options) {\n  if (!options) {\n    return {\n      scopes: DEFAULT_SCOPES\n    };\n  }\n\n  if (options.isOfflineEnabled) {\n    invariant(typeof options.webClientId === 'string' && options.webClientId !== '', 'GoogleSignIn: Offline access (isOfflineEnabled: true) requires a valid google server id `webClientId`');\n  }\n\n  return _objectSpread({}, options, {\n    scopes: options.scopes || DEFAULT_SCOPES\n  });\n}\n\nfunction validateOwnership() {\n  invariant(_isClientUsageEnabled || Constants.appOwnership !== 'expo', 'expo-google-sign-in is not supported in the Expo Client because a custom URL scheme is required at build time. Please refer to the docs for usage outside of Expo www.npmjs.com/package/expo-google-sign-in');\n}\n\nfunction ensureGoogleIsInitializedAsync(_x) {\n  return _ensureGoogleIsInitializedAsync.apply(this, arguments);\n}\n\nfunction _ensureGoogleIsInitializedAsync() {\n  _ensureGoogleIsInitializedAsync = _asyncToGenerator(function* (options) {\n    if (_initialization == null) {\n      return initAsync(options);\n    }\n\n    return _initialization;\n  });\n  return _ensureGoogleIsInitializedAsync.apply(this, arguments);\n}\n\nfunction invokeAuthMethod(_x2) {\n  return _invokeAuthMethod.apply(this, arguments);\n}\n\nfunction _invokeAuthMethod() {\n  _invokeAuthMethod = _asyncToGenerator(function* (method) {\n    if (!ExpoGoogleSignIn[method]) {\n      throw new UnavailabilityError('GoogleSignIn', method);\n    }\n\n    yield ensureGoogleIsInitializedAsync();\n    var payload = yield ExpoGoogleSignIn[method]();\n    var account = payload != null ? new GoogleUser(payload) : null;\n    return setCurrentUser(account);\n  });\n  return _invokeAuthMethod.apply(this, arguments);\n}\n\nexport function allowInClient() {\n  _isClientUsageEnabled = true;\n}\nexport function getCurrentUser() {\n  return _currentUser;\n}\nexport function askForPlayServicesAsync() {\n  return _askForPlayServicesAsync.apply(this, arguments);\n}\n\nfunction _askForPlayServicesAsync() {\n  _askForPlayServicesAsync = _asyncToGenerator(function* () {\n    return yield getPlayServiceAvailability(true);\n  });\n  return _askForPlayServicesAsync.apply(this, arguments);\n}\n\nexport function getPlayServiceAvailability() {\n  return _getPlayServiceAvailability.apply(this, arguments);\n}\n\nfunction _getPlayServiceAvailability() {\n  _getPlayServiceAvailability = _asyncToGenerator(function* () {\n    var shouldAsk = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    validateOwnership();\n\n    if (ExpoGoogleSignIn.arePlayServicesAvailableAsync) {\n      return yield ExpoGoogleSignIn.arePlayServicesAvailableAsync(shouldAsk);\n    } else {\n      return true;\n    }\n  });\n  return _getPlayServiceAvailability.apply(this, arguments);\n}\n\nexport function initAsync(_x3) {\n  return _initAsync.apply(this, arguments);\n}\n\nfunction _initAsync() {\n  _initAsync = _asyncToGenerator(function* (options) {\n    if (!ExpoGoogleSignIn.initAsync) {\n      throw new UnavailabilityError('GoogleSignIn', 'initAsync');\n    }\n\n    _options = validateOptions(options || _options || {});\n    var hasPlayServices = yield getPlayServiceAvailability();\n\n    if (!hasPlayServices) {\n      return;\n    }\n\n    _initialization = ExpoGoogleSignIn.initAsync(_options || {});\n    return _initialization;\n  });\n  return _initAsync.apply(this, arguments);\n}\n\nexport function isSignedInAsync() {\n  return _isSignedInAsync.apply(this, arguments);\n}\n\nfunction _isSignedInAsync() {\n  _isSignedInAsync = _asyncToGenerator(function* () {\n    var user = yield getCurrentUserAsync();\n    return user != null;\n  });\n  return _isSignedInAsync.apply(this, arguments);\n}\n\nexport function isConnectedAsync() {\n  return _isConnectedAsync.apply(this, arguments);\n}\n\nfunction _isConnectedAsync() {\n  _isConnectedAsync = _asyncToGenerator(function* () {\n    return yield ExpoGoogleSignIn.isConnectedAsync();\n  });\n  return _isConnectedAsync.apply(this, arguments);\n}\n\nexport function signInSilentlyAsync() {\n  return _signInSilentlyAsync.apply(this, arguments);\n}\n\nfunction _signInSilentlyAsync() {\n  _signInSilentlyAsync = _asyncToGenerator(function* () {\n    var isConnected = yield isConnectedAsync();\n\n    if (isConnected) {\n      try {\n        var auth = yield invokeAuthMethod('signInSilentlyAsync');\n        return auth;\n      } catch (error) {\n        if (error.code === ERRORS.SIGN_IN_REQUIRED) {\n          return null;\n        }\n\n        throw error;\n      }\n    }\n\n    return null;\n  });\n  return _signInSilentlyAsync.apply(this, arguments);\n}\n\nexport function signInAsync() {\n  return _signInAsync.apply(this, arguments);\n}\n\nfunction _signInAsync() {\n  _signInAsync = _asyncToGenerator(function* () {\n    try {\n      var user = yield invokeAuthMethod('signInAsync');\n      return {\n        type: 'success',\n        user\n      };\n    } catch (error) {\n      if (error.code === ERRORS.SIGN_IN_CANCELLED) {\n        return {\n          type: 'cancel',\n          user: null\n        };\n      }\n\n      throw error;\n    }\n  });\n  return _signInAsync.apply(this, arguments);\n}\n\nexport function signOutAsync() {\n  return _signOutAsync.apply(this, arguments);\n}\n\nfunction _signOutAsync() {\n  _signOutAsync = _asyncToGenerator(function* () {\n    yield invokeAuthMethod('signOutAsync');\n  });\n  return _signOutAsync.apply(this, arguments);\n}\n\nexport function disconnectAsync() {\n  return _disconnectAsync.apply(this, arguments);\n}\n\nfunction _disconnectAsync() {\n  _disconnectAsync = _asyncToGenerator(function* () {\n    yield invokeAuthMethod('disconnectAsync');\n  });\n  return _disconnectAsync.apply(this, arguments);\n}\n\nexport function getCurrentUserAsync() {\n  return _getCurrentUserAsync.apply(this, arguments);\n}\n\nfunction _getCurrentUserAsync() {\n  _getCurrentUserAsync = _asyncToGenerator(function* () {\n    return yield invokeAuthMethod('getCurrentUserAsync');\n  });\n  return _getCurrentUserAsync.apply(this, arguments);\n}\n\nexport function getPhotoAsync() {\n  return _getPhotoAsync.apply(this, arguments);\n}\n\nfunction _getPhotoAsync() {\n  _getPhotoAsync = _asyncToGenerator(function* () {\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;\n\n    if (!ExpoGoogleSignIn.getPhotoAsync) {\n      throw new UnavailabilityError('GoogleSignIn', 'getPhotoAsync');\n    }\n\n    yield ensureGoogleIsInitializedAsync();\n    return yield ExpoGoogleSignIn.getPhotoAsync(size);\n  });\n  return _getPhotoAsync.apply(this, arguments);\n}\n\nexport { default as GoogleAuthData } from \"./GoogleAuthData\";\nexport { default as GoogleAuthentication } from \"./GoogleAuthentication\";\nexport { default as GoogleIdentity } from \"./GoogleIdentity\";\nexport { default as GoogleUser } from \"./GoogleUser\";","map":{"version":3,"sources":["../src/GoogleSignIn.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,SAAP,MAAsB,gBAAtB;AACA,SAAS,mBAAT,QAAoC,kBAApC;AACA,OAAO,SAAP,MAAsB,WAAtB;AAEA,OAAO,gBAAP;AACA,OAAO,UAAP;AAIA,OAAO,IAAM;AAAE,EAAA,MAAF;AAAU,EAAA,MAAV;AAAkB,EAAA;AAAlB,IAA4B,gBAAlC;AAEP,IAAM,cAAc,GAAG,CAAC,MAAM,CAAC,OAAR,EAAiB,MAAM,CAAC,KAAxB,CAAvB;;AAEA,IAAI,eAAJ;;AACA,IAAI,QAAJ;;AACA,IAAI,YAAY,GAAsB,IAAtC;AACA,IAAI,qBAAqB,GAAG,KAA5B;;AAEA,SAAS,cAAT,CAAwB,WAAxB,EAAsD;AACpD,EAAA,YAAY,GAAG,WAAf;AACA,SAAO,YAAP;AACD;;AAED,SAAS,eAAT,CAAyB,OAAzB,EAAsD;AACpD,MAAI,CAAC,OAAL,EAAc;AACZ,WAAO;AACL,MAAA,MAAM,EAAE;AADH,KAAP;AAGD;;AACD,MAAI,OAAO,CAAC,gBAAZ,EAA8B;AAC5B,IAAA,SAAS,CACP,OAAO,OAAO,CAAC,WAAf,KAA+B,QAA/B,IAA2C,OAAO,CAAC,WAAR,KAAwB,EAD5D,EAEP,uGAFO,CAAT;AAID;;AAED,2BACK,OADL;AAEE,IAAA,MAAM,EAAE,OAAO,CAAC,MAAR,IAAkB;AAF5B;AAID;;AAED,SAAS,iBAAT,GAA0B;AACxB,EAAA,SAAS,CACP,qBAAqB,IAAI,SAAS,CAAC,YAAV,KAA2B,MAD7C,EAEP,6MAFO,CAAT;AAID;;SAEc,8B;;;;;sDAAf,WAA8C,OAA9C,EAA2E;AACzE,QAAI,eAAe,IAAI,IAAvB,EAA6B;AAC3B,aAAO,SAAS,CAAC,OAAD,CAAhB;AACD;;AACD,WAAO,eAAP;AACD,G;;;;SAEc,gB;;;;;wCAAf,WAAgC,MAAhC,EAA8C;AAC5C,QAAI,CAAC,gBAAgB,CAAC,MAAD,CAArB,EAA+B;AAC7B,YAAM,IAAI,mBAAJ,CAAwB,cAAxB,EAAwC,MAAxC,CAAN;AACD;;AACD,UAAM,8BAA8B,EAApC;AACA,QAAM,OAAO,SAAS,gBAAgB,CAAC,MAAD,CAAhB,EAAtB;AACA,QAAI,OAAO,GAAG,OAAO,IAAI,IAAX,GAAkB,IAAI,UAAJ,CAAe,OAAf,CAAlB,GAA4C,IAA1D;AACA,WAAO,cAAc,CAAC,OAAD,CAArB;AACD,G;;;;AAED,OAAM,SAAU,aAAV,GAAuB;AAC3B,EAAA,qBAAqB,GAAG,IAAxB;AACD;AAED,OAAM,SAAU,cAAV,GAAwB;AAC5B,SAAO,YAAP;AACD;AAED,gBAAsB,uBAAtB;AAAA;AAAA;;;+CAAO,aAAsC;AAC3C,iBAAa,0BAA0B,CAAC,IAAD,CAAvC;AACD,G;;;;AAED,gBAAsB,0BAAtB;AAAA;AAAA;;;kDAAO,aAAoE;AAAA,QAA1B,SAA0B,uEAAL,KAAK;AACzE,IAAA,iBAAiB;;AAEjB,QAAI,gBAAgB,CAAC,6BAArB,EAAoD;AAClD,mBAAa,gBAAgB,CAAC,6BAAjB,CAA+C,SAA/C,CAAb;AACD,KAFD,MAEO;AACL,aAAO,IAAP;AACD;AACF,G;;;;AAED,gBAAsB,SAAtB;AAAA;AAAA;;;iCAAO,WAAyB,OAAzB,EAAsD;AAC3D,QAAI,CAAC,gBAAgB,CAAC,SAAtB,EAAiC;AAC/B,YAAM,IAAI,mBAAJ,CAAwB,cAAxB,EAAwC,WAAxC,CAAN;AACD;;AAED,IAAA,QAAQ,GAAG,eAAe,CAAC,OAAO,IAAI,QAAX,IAAuB,EAAxB,CAA1B;AAEA,QAAM,eAAe,SAAS,0BAA0B,EAAxD;;AACA,QAAI,CAAC,eAAL,EAAsB;AACpB;AACD;;AAED,IAAA,eAAe,GAAG,gBAAgB,CAAC,SAAjB,CAA2B,QAAQ,IAAI,EAAvC,CAAlB;AAEA,WAAO,eAAP;AACD,G;;;;AAED,gBAAsB,eAAtB;AAAA;AAAA;;;uCAAO,aAA8B;AACnC,QAAM,IAAI,SAAS,mBAAmB,EAAtC;AACA,WAAO,IAAI,IAAI,IAAf;AACD,G;;;;AAED,gBAAsB,gBAAtB;AAAA;AAAA;;;wCAAO,aAA+B;AACpC,iBAAa,gBAAgB,CAAC,gBAAjB,EAAb;AACD,G;;;;AAED,gBAAsB,mBAAtB;AAAA;AAAA;;;2CAAO,aAAkC;AACvC,QAAM,WAAW,SAAS,gBAAgB,EAA1C;;AACA,QAAI,WAAJ,EAAiB;AACf,UAAI;AACF,YAAM,IAAI,SAAS,gBAAgB,CAAC,qBAAD,CAAnC;AACA,eAAO,IAAP;AACD,OAHD,CAGE,OAAO,KAAP,EAAc;AAEd,YAAI,KAAK,CAAC,IAAN,KAAe,MAAM,CAAC,gBAA1B,EAA4C;AAC1C,iBAAO,IAAP;AACD;;AACD,cAAM,KAAN;AACD;AACF;;AACD,WAAO,IAAP;AACD,G;;;;AAED,gBAAsB,WAAtB;AAAA;AAAA;;;mCAAO,aAA0B;AAC/B,QAAI;AACF,UAAM,IAAI,SAAS,gBAAgB,CAAC,aAAD,CAAnC;AACA,aAAO;AAAE,QAAA,IAAI,EAAE,SAAR;AAAmB,QAAA;AAAnB,OAAP;AACD,KAHD,CAGE,OAAO,KAAP,EAAc;AACd,UAAI,KAAK,CAAC,IAAN,KAAe,MAAM,CAAC,iBAA1B,EAA6C;AAC3C,eAAO;AAAE,UAAA,IAAI,EAAE,QAAR;AAAkB,UAAA,IAAI,EAAE;AAAxB,SAAP;AACD;;AACD,YAAM,KAAN;AACD;AACF,G;;;;AAED,gBAAsB,YAAtB;AAAA;AAAA;;;oCAAO,aAA2B;AAChC,UAAM,gBAAgB,CAAC,cAAD,CAAtB;AACD,G;;;;AAED,gBAAsB,eAAtB;AAAA;AAAA;;;uCAAO,aAA8B;AACnC,UAAM,gBAAgB,CAAC,iBAAD,CAAtB;AACD,G;;;;AAED,gBAAsB,mBAAtB;AAAA;AAAA;;;2CAAO,aAAkC;AACvC,iBAAa,gBAAgB,CAAC,qBAAD,CAA7B;AACD,G;;;;AAED,gBAAsB,aAAtB;AAAA;AAAA;;;qCAAO,aAA+C;AAAA,QAAlB,IAAkB,uEAAH,GAAG;;AACpD,QAAI,CAAC,gBAAgB,CAAC,aAAtB,EAAqC;AACnC,YAAM,IAAI,mBAAJ,CAAwB,cAAxB,EAAwC,eAAxC,CAAN;AACD;;AAED,UAAM,8BAA8B,EAApC;AACA,iBAAa,gBAAgB,CAAC,aAAjB,CAA+B,IAA/B,CAAb;AACD,G;;;;AAED,SAAS,OAAO,IAAI,cAApB;AACA,SAAS,OAAO,IAAI,oBAApB;AACA,SAAS,OAAO,IAAI,cAApB;AACA,SAAS,OAAO,IAAI,UAApB","sourcesContent":["import Constants from 'expo-constants';\nimport { UnavailabilityError } from '@unimodules/core';\nimport invariant from 'invariant';\n\nimport ExpoGoogleSignIn from './ExpoGoogleSignIn';\nimport GoogleUser from './GoogleUser';\n\nimport { GoogleSignInOptions, GoogleSignInAuthResult } from './GoogleSignIn.types';\n\nexport const { ERRORS, SCOPES, TYPES } = ExpoGoogleSignIn;\n\nconst DEFAULT_SCOPES = [SCOPES.PROFILE, SCOPES.EMAIL];\n\nlet _initialization: Promise<void>;\nlet _options: GoogleSignInOptions;\nlet _currentUser: GoogleUser | null = null;\nlet _isClientUsageEnabled = false;\n\nfunction setCurrentUser(currentUser: GoogleUser | null): GoogleUser | null {\n  _currentUser = currentUser;\n  return _currentUser;\n}\n\nfunction validateOptions(options?: GoogleSignInOptions): GoogleSignInOptions {\n  if (!options) {\n    return {\n      scopes: DEFAULT_SCOPES,\n    };\n  }\n  if (options.isOfflineEnabled) {\n    invariant(\n      typeof options.webClientId === 'string' && options.webClientId !== '',\n      'GoogleSignIn: Offline access (isOfflineEnabled: true) requires a valid google server id `webClientId`'\n    );\n  }\n\n  return {\n    ...options,\n    scopes: options.scopes || DEFAULT_SCOPES,\n  };\n}\n\nfunction validateOwnership() {\n  invariant(\n    _isClientUsageEnabled || Constants.appOwnership !== 'expo',\n    'expo-google-sign-in is not supported in the Expo Client because a custom URL scheme is required at build time. Please refer to the docs for usage outside of Expo www.npmjs.com/package/expo-google-sign-in'\n  );\n}\n\nasync function ensureGoogleIsInitializedAsync(options?: GoogleSignInOptions): Promise<any> {\n  if (_initialization == null) {\n    return initAsync(options);\n  }\n  return _initialization;\n}\n\nasync function invokeAuthMethod(method: string): Promise<GoogleUser | null> {\n  if (!ExpoGoogleSignIn[method]) {\n    throw new UnavailabilityError('GoogleSignIn', method);\n  }\n  await ensureGoogleIsInitializedAsync();\n  const payload = await ExpoGoogleSignIn[method]();\n  let account = payload != null ? new GoogleUser(payload) : null;\n  return setCurrentUser(account);\n}\n\nexport function allowInClient() {\n  _isClientUsageEnabled = true;\n}\n\nexport function getCurrentUser(): GoogleUser | null {\n  return _currentUser;\n}\n\nexport async function askForPlayServicesAsync(): Promise<boolean> {\n  return await getPlayServiceAvailability(true);\n}\n\nexport async function getPlayServiceAvailability(shouldAsk: boolean = false): Promise<boolean> {\n  validateOwnership();\n\n  if (ExpoGoogleSignIn.arePlayServicesAvailableAsync) {\n    return await ExpoGoogleSignIn.arePlayServicesAvailableAsync(shouldAsk);\n  } else {\n    return true;\n  }\n}\n\nexport async function initAsync(options?: GoogleSignInOptions): Promise<void> {\n  if (!ExpoGoogleSignIn.initAsync) {\n    throw new UnavailabilityError('GoogleSignIn', 'initAsync');\n  }\n\n  _options = validateOptions(options || _options || {});\n\n  const hasPlayServices = await getPlayServiceAvailability();\n  if (!hasPlayServices) {\n    return;\n  }\n\n  _initialization = ExpoGoogleSignIn.initAsync(_options || {});\n\n  return _initialization;\n}\n\nexport async function isSignedInAsync(): Promise<boolean> {\n  const user = await getCurrentUserAsync();\n  return user != null;\n}\n\nexport async function isConnectedAsync(): Promise<boolean> {\n  return await ExpoGoogleSignIn.isConnectedAsync();\n}\n\nexport async function signInSilentlyAsync(): Promise<GoogleUser | null> {\n  const isConnected = await isConnectedAsync();\n  if (isConnected) {\n    try {\n      const auth = await invokeAuthMethod('signInSilentlyAsync');\n      return auth;\n    } catch (error) {\n      /* Return null to create parity with Android */\n      if (error.code === ERRORS.SIGN_IN_REQUIRED) {\n        return null;\n      }\n      throw error;\n    }\n  }\n  return null;\n}\n\nexport async function signInAsync(): Promise<GoogleSignInAuthResult> {\n  try {\n    const user = await invokeAuthMethod('signInAsync');\n    return { type: 'success', user };\n  } catch (error) {\n    if (error.code === ERRORS.SIGN_IN_CANCELLED) {\n      return { type: 'cancel', user: null };\n    }\n    throw error;\n  }\n}\n\nexport async function signOutAsync(): Promise<void> {\n  await invokeAuthMethod('signOutAsync');\n}\n\nexport async function disconnectAsync(): Promise<void> {\n  await invokeAuthMethod('disconnectAsync');\n}\n\nexport async function getCurrentUserAsync(): Promise<GoogleUser | null> {\n  return await invokeAuthMethod('getCurrentUserAsync');\n}\n\nexport async function getPhotoAsync(size: number = 128): Promise<string | null> {\n  if (!ExpoGoogleSignIn.getPhotoAsync) {\n    throw new UnavailabilityError('GoogleSignIn', 'getPhotoAsync');\n  }\n\n  await ensureGoogleIsInitializedAsync();\n  return await ExpoGoogleSignIn.getPhotoAsync(size);\n}\n\nexport { default as GoogleAuthData } from './GoogleAuthData';\nexport { default as GoogleAuthentication } from './GoogleAuthentication';\nexport { default as GoogleIdentity } from './GoogleIdentity';\nexport { default as GoogleUser } from './GoogleUser';\n\nexport {\n  GoogleSignInType,\n  GoogleSignInOptions,\n  GoogleSignInAuthResultType,\n  GoogleSignInAuthResult,\n} from './GoogleSignIn.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}