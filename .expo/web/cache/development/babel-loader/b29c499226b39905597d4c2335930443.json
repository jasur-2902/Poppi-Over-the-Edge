{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { SyntheticPlatformEmitter } from '@unimodules/core';\n\nfunction getStatusFromMedia(media) {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined\n    };\n  }\n\n  var isPlaying = !!(media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2);\n  var status = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100,\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false,\n    rate: media.playbackRate,\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended\n  };\n  return status;\n}\n\nfunction setStatusForMedia(media, status) {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nexport default {\n  get name() {\n    return 'ExponentAV';\n  },\n\n  getStatusForVideo(element) {\n    return _asyncToGenerator(function* () {\n      return getStatusFromMedia(element);\n    })();\n  },\n\n  loadForVideo(element, nativeSource, fullInitialStatus) {\n    return _asyncToGenerator(function* () {\n      return getStatusFromMedia(element);\n    })();\n  },\n\n  unloadForVideo(element) {\n    return _asyncToGenerator(function* () {\n      return getStatusFromMedia(element);\n    })();\n  },\n\n  setStatusForVideo(element, status) {\n    return _asyncToGenerator(function* () {\n      return setStatusForMedia(element, status);\n    })();\n  },\n\n  replayVideo(element, status) {\n    return _asyncToGenerator(function* () {\n      return setStatusForMedia(element, status);\n    })();\n  },\n\n  setAudioMode() {\n    return _asyncToGenerator(function* () {})();\n  },\n\n  setAudioIsEnabled() {\n    return _asyncToGenerator(function* () {})();\n  },\n\n  getStatusForSound(element) {\n    return _asyncToGenerator(function* () {\n      return getStatusFromMedia(element);\n    })();\n  },\n\n  loadForSound(nativeSource, fullInitialStatus) {\n    return _asyncToGenerator(function* () {\n      var source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n      var media = new Audio(source);\n\n      media.ontimeupdate = () => {\n        SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n          key: media,\n          status: getStatusFromMedia(media)\n        });\n      };\n\n      media.onerror = () => {\n        SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n          key: media,\n          error: media.error.message\n        });\n      };\n\n      var status = setStatusForMedia(media, fullInitialStatus);\n      return [media, status];\n    })();\n  },\n\n  unloadForSound(element) {\n    return _asyncToGenerator(function* () {})();\n  },\n\n  setStatusForSound(element, status) {\n    return _asyncToGenerator(function* () {\n      return setStatusForMedia(element, status);\n    })();\n  },\n\n  replaySound(element, status) {\n    return _asyncToGenerator(function* () {\n      return setStatusForMedia(element, status);\n    })();\n  },\n\n  getAudioRecordingStatus() {\n    return _asyncToGenerator(function* () {})();\n  },\n\n  prepareAudioRecorder() {\n    return _asyncToGenerator(function* () {})();\n  },\n\n  startAudioRecording() {\n    return _asyncToGenerator(function* () {})();\n  },\n\n  pauseAudioRecording() {\n    return _asyncToGenerator(function* () {})();\n  },\n\n  stopAudioRecording() {\n    return _asyncToGenerator(function* () {})();\n  },\n\n  unloadAudioRecorder() {\n    return _asyncToGenerator(function* () {})();\n  }\n\n};","map":{"version":3,"sources":["../src/ExponentAV.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { SyntheticPlatformEmitter } from '@unimodules/core';\n\nimport { PlaybackNativeSource, PlaybackStatus, PlaybackStatusToSet } from './AV';\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): PlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: PlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nfunction setStatusForMedia(media: HTMLMediaElement, status: PlaybackStatusToSet): PlaybackStatus {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nexport default {\n  get name(): string {\n    return 'ExponentAV';\n  },\n  async getStatusForVideo(element: HTMLMediaElement): Promise<PlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: PlaybackNativeSource,\n    fullInitialStatus: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<PlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: PlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, PlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {},\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: PlaybackStatusToSet\n  ): Promise<PlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus() {},\n  async prepareAudioRecorder() {},\n  async startAudioRecording() {},\n  async pauseAudioRecording() {},\n  async stopAudioRecording() {},\n  async unloadAudioRecorder() {},\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}