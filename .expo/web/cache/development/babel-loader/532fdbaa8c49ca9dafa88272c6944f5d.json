{"ast":null,"code":"import AnimatedNode from \"./AnimatedNode\";\nimport { val } from \"../utils\";\nimport invariant from 'fbjs/lib/invariant';\n\nfunction reduce(fn) {\n  return input => input.reduce((a, b) => fn(val(a), val(b)));\n}\n\nfunction reduceFrom(fn, initialValue) {\n  return input => input.reduce((a, b) => fn(val(a), val(b)), initialValue);\n}\n\nfunction infix(fn) {\n  return input => fn(val(input[0]), val(input[1]));\n}\n\nfunction single(fn) {\n  return input => fn(val(input[0]));\n}\n\nvar OPERATIONS = {\n  add: reduce((a, b) => a + b),\n  sub: reduce((a, b) => a - b),\n  multiply: reduce((a, b) => a * b),\n  divide: reduce((a, b) => a / b),\n  pow: reduce((a, b) => Math.pow(a, b)),\n  modulo: reduce((a, b) => (a % b + b) % b),\n  sqrt: single(a => Math.sqrt(a)),\n  sin: single(a => Math.sin(a)),\n  cos: single(a => Math.cos(a)),\n  exp: single(a => Math.exp(a)),\n  and: reduceFrom((a, b) => a && b, true),\n  or: reduceFrom((a, b) => a || b, false),\n  not: single(a => !a),\n  defined: single(a => a !== null && a !== undefined && !isNaN(a)),\n  lessThan: infix((a, b) => a < b),\n  eq: infix((a, b) => a == b),\n  greaterThan: infix((a, b) => a > b),\n  lessOrEq: infix((a, b) => a <= b),\n  greaterOrEq: infix((a, b) => a >= b),\n  neq: infix((a, b) => a != b)\n};\nexport default class AnimatedOperator extends AnimatedNode {\n  constructor(operator, input) {\n    super({\n      type: 'op',\n      op: operator,\n      input: input.map(n => n.__nodeID)\n    }, input);\n    this._op = operator;\n    this._input = input;\n  }\n\n  __onEvaluate() {\n    if (!this._operation) {\n      this._operation = OPERATIONS[this._op];\n      invariant(this._operation, \"Illegal operator '%s'\", this._op);\n    }\n\n    return this._operation(this._input);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/react-native-reanimated/src/core/AnimatedOperator.js"],"names":["AnimatedNode","val","invariant","reduce","fn","input","a","b","reduceFrom","initialValue","infix","single","OPERATIONS","add","sub","multiply","divide","pow","Math","modulo","sqrt","sin","cos","exp","and","or","not","defined","undefined","isNaN","lessThan","eq","greaterThan","lessOrEq","greaterOrEq","neq","AnimatedOperator","constructor","operator","type","op","map","n","__nodeID","_op","_input","__onEvaluate","_operation"],"mappings":"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","sourcesContent":["import AnimatedNode from './AnimatedNode';\nimport { val } from '../utils';\n\nimport invariant from 'fbjs/lib/invariant';\n\nfunction reduce(fn) {\n  return input => input.reduce((a, b) => fn(val(a), val(b)));\n}\n\nfunction reduceFrom(fn, initialValue) {\n  return input => input.reduce((a, b) => fn(val(a), val(b)), initialValue);\n}\n\nfunction infix(fn) {\n  return input => fn(val(input[0]), val(input[1]));\n}\n\nfunction single(fn) {\n  return input => fn(val(input[0]));\n}\n\nconst OPERATIONS = {\n  // arithmetic\n  add: reduce((a, b) => a + b),\n  sub: reduce((a, b) => a - b),\n  multiply: reduce((a, b) => a * b),\n  divide: reduce((a, b) => a / b),\n  pow: reduce((a, b) => Math.pow(a, b)),\n  modulo: reduce((a, b) => ((a % b) + b) % b),\n  sqrt: single(a => Math.sqrt(a)),\n  sin: single(a => Math.sin(a)),\n  cos: single(a => Math.cos(a)),\n  exp: single(a => Math.exp(a)),\n\n  // logical\n  and: reduceFrom((a, b) => a && b, true),\n  or: reduceFrom((a, b) => a || b, false),\n  not: single(a => !a),\n  defined: single(a => a !== null && a !== undefined && !isNaN(a)),\n\n  // comparing\n  lessThan: infix((a, b) => a < b),\n  /* eslint-disable-next-line eqeqeq */\n  eq: infix((a, b) => a == b),\n  greaterThan: infix((a, b) => a > b),\n  lessOrEq: infix((a, b) => a <= b),\n  greaterOrEq: infix((a, b) => a >= b),\n  /* eslint-disable-next-line eqeqeq */\n  neq: infix((a, b) => a != b),\n};\n\nexport default class AnimatedOperator extends AnimatedNode {\n  _input;\n  _op;\n  _operation;\n\n  constructor(operator, input) {\n    super(\n      { type: 'op', op: operator, input: input.map(n => n.__nodeID) },\n      input\n    );\n    this._op = operator;\n    this._input = input;\n  }\n\n  __onEvaluate() {\n    if (!this._operation) {\n      this._operation = OPERATIONS[this._op];\n      invariant(this._operation, `Illegal operator '%s'`, this._op);\n    }\n    return this._operation(this._input);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}