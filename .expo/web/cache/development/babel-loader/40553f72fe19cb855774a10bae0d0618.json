{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport ReanimatedModule from \"../ReanimatedModule\";\nvar UPDATED_NODES = [];\nvar loopID = 1;\nvar propUpdatesEnqueued = null;\n\nfunction sanitizeConfig(config) {\n  for (var key in config) {\n    var value = config[key];\n\n    if (value instanceof AnimatedNode) {\n      config[key] = value.__nodeID;\n    }\n  }\n\n  return config;\n}\n\nfunction runPropUpdates() {\n  var visitedNodes = new Set();\n\n  var findAndUpdateNodes = node => {\n    if (visitedNodes.has(node)) {\n      return;\n    } else {\n      visitedNodes.add(node);\n    }\n\n    if (typeof node.update === 'function') {\n      node.update();\n    } else {\n      node.__getChildren().forEach(findAndUpdateNodes);\n    }\n  };\n\n  for (var i = 0; i < UPDATED_NODES.length; i++) {\n    var node = UPDATED_NODES[i];\n    findAndUpdateNodes(node);\n  }\n\n  UPDATED_NODES.length = 0;\n  propUpdatesEnqueued = null;\n  loopID += 1;\n}\n\nvar nodeCount = 0;\nexport default class AnimatedNode {\n  constructor(nodeConfig, inputNodes) {\n    this.__lastLoopID = 0;\n    this.__memoizedValue = null;\n    this.__children = [];\n    this.__nodeID = ++nodeCount;\n    this.__nodeConfig = sanitizeConfig(nodeConfig);\n    this.__initialized = false;\n    this.__inputNodes = inputNodes && inputNodes.filter(node => node instanceof AnimatedNode);\n  }\n\n  __attach() {\n    this.__nativeInitialize();\n\n    this.__inputNodes && this.__inputNodes.forEach(node => node.__addChild(this));\n  }\n\n  __detach() {\n    this.__inputNodes && this.__inputNodes.forEach(node => node.__removeChild(this));\n\n    this.__nativeTearDown();\n  }\n\n  __getValue() {\n    if (this.__lastLoopID < loopID) {\n      this.__lastLoopID = loopID;\n      return this.__memoizedValue = this.__onEvaluate();\n    }\n\n    return this.__memoizedValue;\n  }\n\n  __forceUpdateCache(newValue) {\n    this.__memoizedValue = newValue;\n\n    this.__markUpdated();\n  }\n\n  __dangerouslyRescheduleEvaluate() {\n    this.__lastLoopID = 0;\n\n    this.__markUpdated();\n  }\n\n  __markUpdated() {\n    UPDATED_NODES.push(this);\n\n    if (!propUpdatesEnqueued) {\n      propUpdatesEnqueued = setImmediate(runPropUpdates);\n    }\n  }\n\n  __nativeInitialize() {\n    if (!this.__initialized) {\n      ReanimatedModule.createNode(this.__nodeID, _objectSpread({}, this.__nodeConfig));\n      this.__initialized = true;\n    }\n  }\n\n  __nativeTearDown() {\n    if (this.__initialized) {\n      ReanimatedModule.dropNode(this.__nodeID);\n      this.__initialized = false;\n    }\n  }\n\n  isNativelyInitialized() {\n    return this.__initialized;\n  }\n\n  __onEvaluate() {\n    throw new Error('Missing implementation of onEvaluate');\n  }\n\n  __getProps() {\n    return this.__getValue();\n  }\n\n  __getChildren() {\n    return this.__children;\n  }\n\n  __addChild(child) {\n    if (this.__children.length === 0) {\n      this.__attach();\n    }\n\n    this.__children.push(child);\n\n    child.__nativeInitialize();\n\n    ReanimatedModule.connectNodes(this.__nodeID, child.__nodeID);\n  }\n\n  __removeChild(child) {\n    var index = this.__children.indexOf(child);\n\n    if (index === -1) {\n      console.warn(\"Trying to remove a child that doesn't exist\");\n      return;\n    }\n\n    ReanimatedModule.disconnectNodes(this.__nodeID, child.__nodeID);\n\n    this.__children.splice(index, 1);\n\n    if (this.__children.length === 0) {\n      this.__detach();\n    }\n  }\n\n  _connectAnimatedView(nativeViewTag) {\n    ReanimatedModule.connectNodeToView(this.__nodeID, nativeViewTag);\n  }\n\n  _disconnectAnimatedView(nativeViewTag) {\n    ReanimatedModule.disconnectNodeFromView(this.__nodeID, nativeViewTag);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/react-native-reanimated/src/core/AnimatedNode.js"],"names":["ReanimatedModule","UPDATED_NODES","loopID","propUpdatesEnqueued","sanitizeConfig","config","key","value","AnimatedNode","__nodeID","runPropUpdates","visitedNodes","Set","findAndUpdateNodes","node","has","add","update","__getChildren","forEach","i","length","nodeCount","constructor","nodeConfig","inputNodes","__lastLoopID","__memoizedValue","__children","__nodeConfig","__initialized","__inputNodes","filter","__attach","__nativeInitialize","__addChild","__detach","__removeChild","__nativeTearDown","__getValue","__onEvaluate","__forceUpdateCache","newValue","__markUpdated","__dangerouslyRescheduleEvaluate","push","setImmediate","createNode","dropNode","isNativelyInitialized","Error","__getProps","child","connectNodes","index","indexOf","console","warn","disconnectNodes","splice","_connectAnimatedView","nativeViewTag","connectNodeToView","_disconnectAnimatedView","disconnectNodeFromView"],"mappings":"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","sourcesContent":["import ReanimatedModule from '../ReanimatedModule';\n\nconst UPDATED_NODES = [];\n\nlet loopID = 1;\nlet propUpdatesEnqueued = null;\n\nfunction sanitizeConfig(config) {\n  for (const key in config) {\n    const value = config[key];\n    if (value instanceof AnimatedNode) {\n      config[key] = value.__nodeID;\n    }\n  }\n  return config;\n}\n\nfunction runPropUpdates() {\n  const visitedNodes = new Set();\n  const findAndUpdateNodes = node => {\n    if (visitedNodes.has(node)) {\n      return;\n    } else {\n      visitedNodes.add(node);\n    }\n    if (typeof node.update === 'function') {\n      node.update();\n    } else {\n      node.__getChildren().forEach(findAndUpdateNodes);\n    }\n  };\n  for (let i = 0; i < UPDATED_NODES.length; i++) {\n    const node = UPDATED_NODES[i];\n    findAndUpdateNodes(node);\n  }\n  UPDATED_NODES.length = 0; // clear array\n  propUpdatesEnqueued = null;\n  loopID += 1;\n}\n\nlet nodeCount = 0;\n\nexport default class AnimatedNode {\n  constructor(nodeConfig, inputNodes) {\n    this.__nodeID = ++nodeCount;\n    this.__nodeConfig = sanitizeConfig(nodeConfig);\n    this.__initialized = false;\n    this.__inputNodes =\n      inputNodes && inputNodes.filter(node => node instanceof AnimatedNode);\n  }\n\n  __attach() {\n    this.__nativeInitialize();\n    this.__inputNodes &&\n      this.__inputNodes.forEach(node => node.__addChild(this));\n  }\n\n  __detach() {\n    this.__inputNodes &&\n      this.__inputNodes.forEach(node => node.__removeChild(this));\n    this.__nativeTearDown();\n  }\n\n  __lastLoopID = 0;\n  __memoizedValue = null;\n\n  __children = [];\n\n  __getValue() {\n    if (this.__lastLoopID < loopID) {\n      this.__lastLoopID = loopID;\n      return (this.__memoizedValue = this.__onEvaluate());\n    }\n    return this.__memoizedValue;\n  }\n\n  __forceUpdateCache(newValue) {\n    this.__memoizedValue = newValue;\n    this.__markUpdated();\n  }\n\n  __dangerouslyRescheduleEvaluate() {\n    this.__lastLoopID = 0;\n    this.__markUpdated();\n  }\n\n  __markUpdated() {\n    UPDATED_NODES.push(this);\n    if (!propUpdatesEnqueued) {\n      propUpdatesEnqueued = setImmediate(runPropUpdates);\n    }\n  }\n\n  __nativeInitialize() {\n    if (!this.__initialized) {\n      ReanimatedModule.createNode(this.__nodeID, { ...this.__nodeConfig });\n      this.__initialized = true;\n    }\n  }\n\n  __nativeTearDown() {\n    if (this.__initialized) {\n      ReanimatedModule.dropNode(this.__nodeID);\n      this.__initialized = false;\n    }\n  }\n\n  isNativelyInitialized() {\n    return this.__initialized;\n  }\n\n  __onEvaluate() {\n    throw new Error('Missing implementation of onEvaluate');\n  }\n\n  __getProps() {\n    return this.__getValue();\n  }\n\n  __getChildren() {\n    return this.__children;\n  }\n\n  __addChild(child) {\n    if (this.__children.length === 0) {\n      this.__attach();\n    }\n    this.__children.push(child);\n    child.__nativeInitialize();\n\n    ReanimatedModule.connectNodes(this.__nodeID, child.__nodeID);\n  }\n\n  __removeChild(child) {\n    const index = this.__children.indexOf(child);\n    if (index === -1) {\n      console.warn(\"Trying to remove a child that doesn't exist\");\n      return;\n    }\n    ReanimatedModule.disconnectNodes(this.__nodeID, child.__nodeID);\n\n    this.__children.splice(index, 1);\n    if (this.__children.length === 0) {\n      this.__detach();\n    }\n  }\n\n  _connectAnimatedView(nativeViewTag) {\n    ReanimatedModule.connectNodeToView(this.__nodeID, nativeViewTag);\n  }\n\n  _disconnectAnimatedView(nativeViewTag) {\n    ReanimatedModule.disconnectNodeFromView(this.__nodeID, nativeViewTag);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}