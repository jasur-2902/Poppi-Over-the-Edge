{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { UnavailabilityError } from '@unimodules/core';\nimport ExpoCrypto from \"./ExpoCrypto\";\nimport { CryptoDigestAlgorithm, CryptoEncoding } from \"./Crypto.types\";\nexport * from \"./Crypto.types\";\n\nclass CryptoError extends TypeError {\n  constructor(message) {\n    super(\"expo-crypto: \".concat(message));\n    this.code = 'ERR_CRYPTO';\n  }\n\n}\n\nfunction assertAlgorithm(algorithm) {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\"Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.\".concat(Object.keys(CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.')));\n  }\n}\n\nfunction assertData(data) {\n  if (typeof data !== 'string') {\n    throw new CryptoError(\"Invalid data provided. Expected a string.\");\n  }\n}\n\nfunction assertEncoding(encoding) {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\"Invalid encoding provided. Expected one of: CryptoEncoding.\".concat(Object.keys(CryptoEncoding).join(', CryptoEncoding.')));\n  }\n}\n\nexport function digestStringAsync(_x, _x2) {\n  return _digestStringAsync.apply(this, arguments);\n}\n\nfunction _digestStringAsync() {\n  _digestStringAsync = _asyncToGenerator(function* (algorithm, data) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      encoding: CryptoEncoding.HEX\n    };\n\n    if (!ExpoCrypto.digestStringAsync) {\n      throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n    }\n\n    assertAlgorithm(algorithm);\n    assertData(data);\n    assertEncoding(options.encoding);\n    return yield ExpoCrypto.digestStringAsync(algorithm, data, options);\n  });\n  return _digestStringAsync.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/Crypto.ts"],"names":[],"mappings":";;;;AAAA,SAAS,mBAAT,QAAoC,kBAApC;AACA,OAAO,UAAP;AAEA,SAAS,qBAAT,EAAgC,cAAhC;AACA;;AAEA,MAAM,WAAN,SAA0B,SAA1B,CAAmC;AAGjC,EAAA,WAAA,CAAY,OAAZ,EAA2B;AACzB,iCAAsB,OAAtB;AAHF,SAAA,IAAA,GAAO,YAAP;AAIC;;AALgC;;AAQnC,SAAS,eAAT,CAAyB,SAAzB,EAAyD;AACvD,MAAI,CAAC,MAAM,CAAC,MAAP,CAAc,qBAAd,EAAqC,QAArC,CAA8C,SAA9C,CAAL,EAA+D;AAC7D,UAAM,IAAI,WAAJ,8EACkE,MAAM,CAAC,IAAP,CACpE,qBADoE,EAEpE,IAFoE,CAE/D,mCAF+D,CADlE,EAAN;AAKD;AACF;;AAED,SAAS,UAAT,CAAoB,IAApB,EAAgC;AAC9B,MAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAM,IAAI,WAAJ,6CAAN;AACD;AACF;;AAED,SAAS,cAAT,CAAwB,QAAxB,EAAgD;AAC9C,MAAI,CAAC,MAAM,CAAC,MAAP,CAAc,cAAd,EAA8B,QAA9B,CAAuC,QAAvC,CAAL,EAAuD;AACrD,UAAM,IAAI,WAAJ,sEAC0D,MAAM,CAAC,IAAP,CAC5D,cAD4D,EAE5D,IAF4D,CAEvD,mBAFuD,CAD1D,EAAN;AAKD;AACF;;AAED,gBAAsB,iBAAtB;AAAA;AAAA;;;yCAAO,WACL,SADK,EAEL,IAFK,EAG0D;AAAA,QAA/D,OAA+D,uEAAhC;AAAE,MAAA,QAAQ,EAAE,cAAc,CAAC;AAA3B,KAAgC;;AAE/D,QAAI,CAAC,UAAU,CAAC,iBAAhB,EAAmC;AACjC,YAAM,IAAI,mBAAJ,CAAwB,aAAxB,EAAuC,mBAAvC,CAAN;AACD;;AAED,IAAA,eAAe,CAAC,SAAD,CAAf;AACA,IAAA,UAAU,CAAC,IAAD,CAAV;AACA,IAAA,cAAc,CAAC,OAAO,CAAC,QAAT,CAAd;AAEA,iBAAa,UAAU,CAAC,iBAAX,CAA6B,SAA7B,EAAwC,IAAxC,EAA8C,OAA9C,CAAb;AACD,G","sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\nimport ExpoCrypto from './ExpoCrypto';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}