{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { NativeModulesProxy } from 'expo-core';\nimport invariant from 'invariant';\nvar {\n  ExpoAppAuth\n} = NativeModulesProxy;\n\nvar isValidString = s => s && typeof s === 'string';\n\nfunction isValidClientId(clientId) {\n  if (!isValidString(clientId)) throw new Error('Config error: clientId must be a string');\n}\n\nfunction isValidProps(_ref) {\n  var {\n    isRefresh,\n    issuer,\n    redirectUrl,\n    clientId,\n    clientSecret,\n    scopes,\n    additionalParameters,\n    serviceConfiguration\n  } = _ref;\n\n  var _serviceConfigIsValid = serviceConfiguration && isValidString(serviceConfiguration.authorizationEndpoint) && isValidString(serviceConfiguration.tokenEndpoint);\n\n  if (!isValidString(issuer) && !_serviceConfigIsValid) throw new Error('Invalid you must provide either an issuer or a service endpoints');\n  if (!isValidString(redirectUrl)) throw new Error('Config error: redirectUrl must be a string');\n  isValidClientId(clientId);\n}\n\nfunction _executeAsync(_x) {\n  return _executeAsync2.apply(this, arguments);\n}\n\nfunction _executeAsync2() {\n  _executeAsync2 = _asyncToGenerator(function* (props) {\n    if (!props.redirectUrl) {\n      props.redirectUrl = \"\".concat(ExpoAppAuth.OAuthRedirect, \":/oauthredirect\");\n    }\n\n    isValidProps(props);\n    return yield ExpoAppAuth.executeAsync(props);\n  });\n  return _executeAsync2.apply(this, arguments);\n}\n\nexport function authAsync(_x2) {\n  return _authAsync.apply(this, arguments);\n}\n\nfunction _authAsync() {\n  _authAsync = _asyncToGenerator(function* (props) {\n    return yield _executeAsync(props);\n  });\n  return _authAsync.apply(this, arguments);\n}\n\nexport function refreshAsync(_x3, _x4) {\n  return _refreshAsync.apply(this, arguments);\n}\n\nfunction _refreshAsync() {\n  _refreshAsync = _asyncToGenerator(function* (props, refreshToken) {\n    if (!refreshToken) throw new Error('Please include the refreshToken');\n    return yield _executeAsync(_objectSpread({\n      isRefresh: true,\n      refreshToken\n    }, props));\n  });\n  return _refreshAsync.apply(this, arguments);\n}\n\nexport function revokeAsync(_x5, _x6) {\n  return _revokeAsync.apply(this, arguments);\n}\n\nfunction _revokeAsync() {\n  _revokeAsync = _asyncToGenerator(function* (_ref2, _ref3) {\n    var {\n      clientId,\n      issuer,\n      serviceConfiguration\n    } = _ref2;\n    var {\n      token,\n      isClientIdProvided = false\n    } = _ref3;\n    if (!token) throw new Error('Please include the token to revoke');\n    isValidClientId(clientId);\n\n    if (!isValidString(issuer) || serviceConfiguration && !isValidString(serviceConfiguration.revocationEndpoint)) {\n      throw new Error('Config error: you must provide either an issuer or a revocation endpoint');\n    }\n\n    var revocationEndpoint;\n\n    if (serviceConfiguration && serviceConfiguration.revocationEndpoint) {\n      revocationEndpoint = serviceConfiguration.revocationEndpoint;\n    } else {\n      var response = yield fetch(\"\".concat(issuer, \"/.well-known/openid-configuration\"));\n      var openidConfig = yield response.json();\n      invariant(openidConfig.revocation_endpoint, 'The OpenID config does not specify a revocation endpoint');\n      revocationEndpoint = openidConfig.revocation_endpoint;\n    }\n\n    var body = \"token=\".concat(token).concat(isClientIdProvided ? \"&client_id=\".concat(clientId) : '');\n    var headers = {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    };\n\n    try {\n      var results = yield fetch(revocationEndpoint, {\n        method: 'POST',\n        headers,\n        body\n      });\n      return results;\n    } catch (error) {\n      throw new Error(\"Failed to revoke token \".concat(error.message));\n    }\n  });\n  return _revokeAsync.apply(this, arguments);\n}\n\nexport var {\n  OAuthRedirect,\n  URLSchemes\n} = ExpoAppAuth;","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/expo-app-auth/src/AppAuth.js"],"names":["NativeModulesProxy","invariant","ExpoAppAuth","isValidString","s","isValidClientId","clientId","Error","isValidProps","isRefresh","issuer","redirectUrl","clientSecret","scopes","additionalParameters","serviceConfiguration","_serviceConfigIsValid","authorizationEndpoint","tokenEndpoint","_executeAsync","props","OAuthRedirect","executeAsync","authAsync","refreshAsync","refreshToken","revokeAsync","token","isClientIdProvided","revocationEndpoint","response","fetch","openidConfig","json","revocation_endpoint","body","headers","results","method","error","message","URLSchemes"],"mappings":"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","sourcesContent":["//@flow\nimport { NativeModulesProxy } from 'expo-core';\nimport invariant from 'invariant';\nconst { ExpoAppAuth } = NativeModulesProxy;\n\nexport type OAuthServiceConfiguration = {\n  revocationEndpoint?: string,\n  authorizationEndpoint?: string,\n  registrationEndpoint?: string,\n  tokenEndpoint: string,\n};\n\n/* ASCII string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. */\nexport type OAuthDisplayParameter = 'page' | 'popup' | 'touch' | 'wap';\n\n/*\n * Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization\n * Server prompts the End-User for reauthentication and consent.\n */\nexport type OAuthPromptParameter = 'none' | 'login' | 'consent' | 'select_account';\n\n/*\n * String value used to associate a Client session with an ID Token, and to mitigate replay attacks.\n * The value is passed through unmodified from the Authentication Request to the ID Token.\n * Sufficient entropy MUST be present in the nonce values used to prevent attackers from guessing values.\n * For implementation notes, see: https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes\n */\nexport type OAuthNonceParameter = string;\n\n/*\n * End-User's preferred languages and scripts for the user interface,\n * represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference.\n * For instance, the value \"fr-CA fr en\" represents a preference for French as spoken in Canada, then French (without a region designation),\n * followed by English (without a region designation).\n * An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider.\n */\nexport type OAuthUILocalesParameter = string;\n\n/*\n * ID Token previously issued by the Authorization Server being passed as a\n * hint about the End-User's current or past authenticated session with the Client.\n * If the End-User identified by the ID Token is logged in or is logged in by the\n * request, then the Authorization Server returns a positive response; otherwise,\n * it SHOULD return an error, such as login_required.\n * When possible, an id_token_hint SHOULD be present when prompt=none is used and an\n *  invalid_request error MAY be returned if it is not; however, the server\n * SHOULD respond successfully when possible, even if it is not present.\n * The Authorization Server need not be listed as an audience of the ID\n * Token when it is used as an id_token_hint value.\n * If the ID Token received by the RP from the OP is encrypted, to use it as an\n * `id_token_hint`, the Client MUST decrypt the signed ID Token contained within the\n * encrypted ID Token.\n * The Client MAY re-encrypt the signed ID token to the Authentication Server using\n * a key that enables the server to decrypt the ID Token, and use the re-encrypted\n * ID token as the `id_token_hint` value.\n */\nexport type OAuthIDTokenHintParameter = string;\n\n/*\n * Maximum Authentication Age.\n * Specifies the allowable elapsed time in seconds since the last time the End-User was actively authenticated by the OP.\n * If the elapsed time is greater than this value, the OP MUST attempt to actively re-authenticate the End-User.\n * (The max_age request parameter corresponds to the OpenID 2.0\n * https://openid.net/specs/openid-connect-core-1_0.html#OpenID.PAPE `max_auth_age` request parameter.)\n * When max_age is used, the ID Token returned MUST include an auth_time Claim Value.\n */\nexport type OAuthMaxAgeParameter = string;\n\n/*\n * Hint to the Authorization Server about the login identifier the End-User\n * might use to log in (if necessary).\n * This hint can be used by an RP if it first asks the End-User for their\n * e-mail address (or other identifier) and then wants to pass that value\n * as a hint to the discovered authorization service.\n * It is RECOMMENDED that the hint value match the value used for discovery.\n * This value MAY also be a phone number in the format specified for the\n * `phone_number` Claim.\n * The use of this parameter is left to the OP's discretion.\n */\nexport type OAuthLoginHintParameter = string;\n\n/*\n * Requested Authentication Context Class Reference values.\n * Space-separated string that specifies the acr values that the Authorization Server\n * is being requested to use for processing this Authentication Request, with the\n * values appearing in order of preference.\n * The Authentication Context Class satisfied by the authentication performed is\n * returned as the acr Claim Value, as specified in Section 2.\n * The acr Claim is requested as a Voluntary Claim by this parameter.\n */\nexport type OAuthACRValuesParameter = string;\n\nexport type OAuthParameters = {\n  nonce?: OAuthNonceParameter,\n  display?: OAuthParametersDisplay,\n  prompt?: OAuthPromptParameter,\n  max_age?: OAuthMaxAgeParameter,\n  ui_locales?: OAuthUILocalesParameter,\n  id_token_hint?: OAuthIDTokenHintParameter,\n  login_hint?: OAuthLoginHintParameter,\n  acr_values?: OAuthACRValuesParameter,\n  [string]: string,\n};\n\nexport type OAuthBaseProps = {\n  clientId: string,\n  issuer: string,\n  serviceConfiguration?: OAuthServiceConfiguration,\n};\n\nexport type OAuthProps = OAuthBaseProps & {\n  redirectUrl?: string,\n  clientSecret?: string,\n  scopes?: Array<string>,\n  additionalParameters?: OAuthParameters,\n  canMakeInsecureRequests?: boolean,\n};\n\nexport type OAuthRevokeOptions = {\n  token: string,\n  isClientIdProvided: boolean,\n};\n\nexport type TokenResponse = {\n  accessToken: string | null,\n  accessTokenExpirationDate: string | null,\n  additionalParameters: { [string]: any } | null,\n  idToken: string | null,\n  tokenType: string | null,\n  refreshToken?: string,\n};\n\nconst isValidString = (s: ?string): boolean => s && typeof s === 'string';\n\nfunction isValidClientId(clientId: ?string): void {\n  if (!isValidString(clientId)) throw new Error('Config error: clientId must be a string');\n}\n\nfunction isValidProps({\n  isRefresh,\n  issuer,\n  redirectUrl,\n  clientId,\n  clientSecret,\n  scopes,\n  additionalParameters,\n  serviceConfiguration,\n}: OAuthProps): void {\n  const _serviceConfigIsValid =\n    serviceConfiguration &&\n    isValidString(serviceConfiguration.authorizationEndpoint) &&\n    isValidString(serviceConfiguration.tokenEndpoint);\n\n  if (!isValidString(issuer) && !_serviceConfigIsValid)\n    throw new Error('Invalid you must provide either an issuer or a service endpoints');\n  if (!isValidString(redirectUrl)) throw new Error('Config error: redirectUrl must be a string');\n  isValidClientId(clientId);\n}\n\nasync function _executeAsync(props: OAuthProps): Promise<TokenResponse> {\n  if (!props.redirectUrl) {\n    props.redirectUrl = `${ExpoAppAuth.OAuthRedirect}:/oauthredirect`;\n  }\n  isValidProps(props);\n  return await ExpoAppAuth.executeAsync(props);\n}\n\nexport async function authAsync(props: OAuthProps): Promise<TokenResponse> {\n  return await _executeAsync(props);\n}\n\nexport async function refreshAsync(\n  props: OAuthProps,\n  refreshToken: string\n): Promise<TokenResponse> {\n  if (!refreshToken) throw new Error('Please include the refreshToken');\n  return await _executeAsync({\n    isRefresh: true,\n    refreshToken,\n    ...props,\n  });\n}\n\nexport async function revokeAsync(\n  { clientId, issuer, serviceConfiguration }: OAuthBaseProps,\n  { token, isClientIdProvided = false }: OAuthRevokeOptions\n): Promise<any> {\n  if (!token) throw new Error('Please include the token to revoke');\n\n  isValidClientId(clientId);\n\n  if (\n    !isValidString(issuer) ||\n    (serviceConfiguration && !isValidString(serviceConfiguration.revocationEndpoint))\n  ) {\n    throw new Error('Config error: you must provide either an issuer or a revocation endpoint');\n  }\n\n  let revocationEndpoint;\n  if (serviceConfiguration && serviceConfiguration.revocationEndpoint) {\n    revocationEndpoint = serviceConfiguration.revocationEndpoint;\n  } else {\n    const response = await fetch(`${issuer}/.well-known/openid-configuration`);\n    const openidConfig = await response.json();\n\n    invariant(\n      openidConfig.revocation_endpoint,\n      'The OpenID config does not specify a revocation endpoint'\n    );\n\n    revocationEndpoint = openidConfig.revocation_endpoint;\n  }\n\n  const body = `token=${token}${isClientIdProvided ? `&client_id=${clientId}` : ''}`;\n  const headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n  try {\n    const results = await fetch(revocationEndpoint, {\n      method: 'POST',\n      headers,\n      body,\n    });\n    return results;\n  } catch (error) {\n    throw new Error(`Failed to revoke token ${error.message}`);\n  }\n}\n\nexport const { OAuthRedirect, URLSchemes } = ExpoAppAuth;\n"]},"metadata":{},"sourceType":"module"}