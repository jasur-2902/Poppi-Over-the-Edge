{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { CodedError, UnavailabilityError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport ExpoAppAuth from \"./ExpoAppAuth\";\n\nfunction isValidServiceConfiguration(config) {\n  return !!(config && typeof config.authorizationEndpoint === 'string' && typeof config.tokenEndpoint === 'string');\n}\n\nfunction assertValidClientId(clientId) {\n  if (typeof clientId !== 'string' || !clientId.length) {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', '`clientId` must be a string with more than 0 characters');\n  }\n}\n\nfunction assertValidProps(_ref) {\n  var {\n    issuer,\n    redirectUrl,\n    clientId,\n    serviceConfiguration\n  } = _ref;\n\n  if (typeof issuer !== 'string' && !isValidServiceConfiguration(serviceConfiguration)) {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', 'You must provide either an `issuer` or both `authorizationEndpoint` and `tokenEndpoint`');\n  }\n\n  if (typeof redirectUrl !== 'string') {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', '`redirectUrl` must be a string');\n  }\n\n  assertValidClientId(clientId);\n}\n\nfunction _executeAsync(_x) {\n  return _executeAsync2.apply(this, arguments);\n}\n\nfunction _executeAsync2() {\n  _executeAsync2 = _asyncToGenerator(function* (props) {\n    if (!props.redirectUrl) {\n      props.redirectUrl = getDefaultOAuthRedirect();\n    }\n\n    assertValidProps(props);\n    return yield ExpoAppAuth.executeAsync(props);\n  });\n  return _executeAsync2.apply(this, arguments);\n}\n\nexport function getDefaultOAuthRedirect() {\n  return \"\".concat(ExpoAppAuth.OAuthRedirect, \":/oauthredirect\");\n}\nexport function authAsync(_x2) {\n  return _authAsync.apply(this, arguments);\n}\n\nfunction _authAsync() {\n  _authAsync = _asyncToGenerator(function* (props) {\n    if (!ExpoAppAuth.executeAsync) {\n      throw new UnavailabilityError('expo-app-auth', 'authAsync');\n    }\n\n    return yield _executeAsync(props);\n  });\n  return _authAsync.apply(this, arguments);\n}\n\nexport function refreshAsync(_x3, _x4) {\n  return _refreshAsync.apply(this, arguments);\n}\n\nfunction _refreshAsync() {\n  _refreshAsync = _asyncToGenerator(function* (props, refreshToken) {\n    if (!ExpoAppAuth.executeAsync) {\n      throw new UnavailabilityError('expo-app-auth', 'refreshAsync');\n    }\n\n    if (!refreshToken) {\n      throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot refresh with null `refreshToken`');\n    }\n\n    return yield _executeAsync(_objectSpread({\n      isRefresh: true,\n      refreshToken\n    }, props));\n  });\n  return _refreshAsync.apply(this, arguments);\n}\n\nexport function revokeAsync(_x5, _x6) {\n  return _revokeAsync.apply(this, arguments);\n}\n\nfunction _revokeAsync() {\n  _revokeAsync = _asyncToGenerator(function* (_ref2, _ref3) {\n    var {\n      clientId,\n      issuer,\n      serviceConfiguration\n    } = _ref2;\n    var {\n      token,\n      isClientIdProvided = false\n    } = _ref3;\n\n    if (!token) {\n      throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot revoke a null `token`');\n    }\n\n    assertValidClientId(clientId);\n    var revocationEndpoint;\n\n    if (serviceConfiguration && serviceConfiguration.revocationEndpoint) {\n      revocationEndpoint = serviceConfiguration.revocationEndpoint;\n    } else {\n      var response = yield fetch(\"\".concat(issuer, \"/.well-known/openid-configuration\"));\n      var openidConfig = yield response.json();\n      invariant(openidConfig.revocation_endpoint, 'The OpenID config does not specify a revocation endpoint');\n      revocationEndpoint = openidConfig.revocation_endpoint;\n    }\n\n    var encodedClientID = encodeURIComponent(clientId);\n    var encodedToken = encodeURIComponent(token);\n    var body = \"token=\".concat(encodedToken).concat(isClientIdProvided ? \"&client_id=\".concat(encodedClientID) : '');\n    var headers = {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    };\n\n    try {\n      var results = yield fetch(revocationEndpoint, {\n        method: 'POST',\n        headers,\n        body\n      });\n      return results;\n    } catch (error) {\n      throw new CodedError('ERR_APP_AUTH_REVOKE_FAILED', error.message);\n    }\n  });\n  return _revokeAsync.apply(this, arguments);\n}\n\nfunction parseAuthRevocationResults(_x7) {\n  return _parseAuthRevocationResults.apply(this, arguments);\n}\n\nfunction _parseAuthRevocationResults() {\n  _parseAuthRevocationResults = _asyncToGenerator(function* (results) {\n    var data = yield results.json();\n    var token = results.headers['update-client-auth'];\n\n    if (results.ok) {\n      return {\n        type: 'success',\n        status: results.status,\n        data,\n        token\n      };\n    } else if (results.status == 503 && results.headers['retry-after']) {\n      var retryAfterValue = results.headers['retry-after'];\n      var retryAfter;\n\n      if (retryAfterValue) {\n        retryAfter = parseRetryTime(retryAfterValue);\n      }\n\n      return {\n        type: 'failed',\n        status: results.status,\n        data,\n        token,\n        retryAfter\n      };\n    } else {\n      return {\n        type: 'error',\n        status: results.status,\n        data,\n        token\n      };\n    }\n  });\n  return _parseAuthRevocationResults.apply(this, arguments);\n}\n\nfunction parseRetryTime(value) {\n  if (/^\\d+$/.test(value)) {\n    return parseInt(value, 10) * 1000;\n  }\n\n  var retry = Date.parse(value);\n\n  if (isNaN(retry)) {\n    throw new CodedError('ERR_APP_AUTH_FETCH_RETRY_TIME', 'Cannot parse the Retry-After header value returned by the server: ' + value);\n  }\n\n  var now = Date.now();\n  var parsedDate = new Date(retry);\n  return parsedDate.getTime() - now;\n}\n\nexport var {\n  OAuthRedirect,\n  URLSchemes\n} = ExpoAppAuth;","map":{"version":3,"sources":["../src/AppAuth.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodedError, UnavailabilityError } from '@unimodules/core';\nimport invariant from 'invariant';\n\nimport {\n  OAuthBaseProps,\n  OAuthProps,\n  OAuthRevokeOptions,\n  OAuthServiceConfiguration,\n  TokenResponse,\n} from './AppAuth.types';\nimport ExpoAppAuth from './ExpoAppAuth';\n\nexport * from './AppAuth.types';\n\nfunction isValidServiceConfiguration(config?: OAuthServiceConfiguration): boolean {\n  return !!(\n    config &&\n    typeof config.authorizationEndpoint === 'string' &&\n    typeof config.tokenEndpoint === 'string'\n  );\n}\n\nfunction assertValidClientId(clientId?: string): void {\n  if (typeof clientId !== 'string' || !clientId.length) {\n    throw new CodedError(\n      'ERR_APP_AUTH_INVALID_CONFIG',\n      '`clientId` must be a string with more than 0 characters'\n    );\n  }\n}\n\nfunction assertValidProps({\n  issuer,\n  redirectUrl,\n  clientId,\n  serviceConfiguration,\n}: OAuthProps): void {\n  if (typeof issuer !== 'string' && !isValidServiceConfiguration(serviceConfiguration)) {\n    throw new CodedError(\n      'ERR_APP_AUTH_INVALID_CONFIG',\n      'You must provide either an `issuer` or both `authorizationEndpoint` and `tokenEndpoint`'\n    );\n  }\n  if (typeof redirectUrl !== 'string') {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', '`redirectUrl` must be a string');\n  }\n  assertValidClientId(clientId);\n}\n\nasync function _executeAsync(props: OAuthProps): Promise<TokenResponse> {\n  if (!props.redirectUrl) {\n    props.redirectUrl = getDefaultOAuthRedirect();\n  }\n  assertValidProps(props);\n  return await ExpoAppAuth.executeAsync(props);\n}\n\nexport function getDefaultOAuthRedirect(): string {\n  return `${ExpoAppAuth.OAuthRedirect}:/oauthredirect`;\n}\n\nexport async function authAsync(props: OAuthProps): Promise<TokenResponse> {\n  if (!ExpoAppAuth.executeAsync) {\n    throw new UnavailabilityError('expo-app-auth', 'authAsync');\n  }\n  return await _executeAsync(props);\n}\n\nexport async function refreshAsync(\n  props: OAuthProps,\n  refreshToken: string\n): Promise<TokenResponse> {\n  if (!ExpoAppAuth.executeAsync) {\n    throw new UnavailabilityError('expo-app-auth', 'refreshAsync');\n  }\n  if (!refreshToken) {\n    throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot refresh with null `refreshToken`');\n  }\n  return await _executeAsync({\n    isRefresh: true,\n    refreshToken,\n    ...props,\n  });\n}\n\n/* JS Method */\nexport async function revokeAsync(\n  { clientId, issuer, serviceConfiguration }: OAuthBaseProps,\n  { token, isClientIdProvided = false }: OAuthRevokeOptions\n): Promise<any> {\n  if (!token) {\n    throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot revoke a null `token`');\n  }\n\n  assertValidClientId(clientId);\n\n  let revocationEndpoint;\n  if (serviceConfiguration && serviceConfiguration.revocationEndpoint) {\n    revocationEndpoint = serviceConfiguration.revocationEndpoint;\n  } else {\n    // For Open IDC providers only.\n    const response = await fetch(`${issuer}/.well-known/openid-configuration`);\n    const openidConfig = await response.json();\n\n    invariant(\n      openidConfig.revocation_endpoint,\n      'The OpenID config does not specify a revocation endpoint'\n    );\n\n    revocationEndpoint = openidConfig.revocation_endpoint;\n  }\n\n  const encodedClientID = encodeURIComponent(clientId);\n  const encodedToken = encodeURIComponent(token);\n  const body = `token=${encodedToken}${isClientIdProvided ? `&client_id=${encodedClientID}` : ''}`;\n  const headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n  try {\n    // https://tools.ietf.org/html/rfc7009#section-2.2\n    const results = await fetch(revocationEndpoint, {\n      method: 'POST',\n      headers,\n      body,\n    });\n\n    return results;\n  } catch (error) {\n    throw new CodedError('ERR_APP_AUTH_REVOKE_FAILED', error.message);\n  }\n}\n\nasync function parseAuthRevocationResults(results: Response): Promise<any> {\n  const data = await results.json();\n  const token = results.headers['update-client-auth'];\n  // the token has been revoked successfully or the client submitted an invalid token.\n  if (results.ok) {\n    // successful op\n    return { type: 'success', status: results.status, data, token };\n  } else if (results.status == 503 && results.headers['retry-after']) {\n    // Failed op\n    const retryAfterValue = results.headers['retry-after'];\n    let retryAfter: number | undefined;\n    if (retryAfterValue) {\n      retryAfter = parseRetryTime(retryAfterValue);\n    }\n    // the client must assume the token still exists and may retry after a reasonable delay.\n    return { type: 'failed', status: results.status, data, token, retryAfter };\n  } else {\n    // Error\n    return { type: 'error', status: results.status, data, token };\n  }\n}\n\nfunction parseRetryTime(value: string): number {\n  // In accordance with RFC2616, Section 14.37. Timout may be of format seconds or future date time value\n  if (/^\\d+$/.test(value)) {\n    return parseInt(value, 10) * 1000;\n  }\n  const retry = Date.parse(value);\n  if (isNaN(retry)) {\n    throw new CodedError(\n      'ERR_APP_AUTH_FETCH_RETRY_TIME',\n      'Cannot parse the Retry-After header value returned by the server: ' + value\n    );\n  }\n  const now = Date.now();\n  const parsedDate = new Date(retry);\n  return parsedDate.getTime() - now;\n}\n\nexport const { OAuthRedirect, URLSchemes } = ExpoAppAuth;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}