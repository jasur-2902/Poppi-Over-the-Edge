{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport UUID from 'uuid-js';\nimport LogSerialization from \"./LogSerialization\";\n\nvar _sessionId = UUID.create().toString();\n\nvar _logQueue = [];\n\nvar _transportEventEmitter = new EventEmitter();\n\nvar _logCounter = 0;\nvar _isSendingLogs = false;\nvar _completionPromise = null;\nvar _resolveCompletion = null;\n\nfunction enqueueRemoteLogAsync(_x, _x2, _x3) {\n  return _enqueueRemoteLogAsync.apply(this, arguments);\n}\n\nfunction _enqueueRemoteLogAsync() {\n  _enqueueRemoteLogAsync = _asyncToGenerator(function* (level, additionalFields, data) {\n    if (_isReactNativeWarning(data)) {\n      if (data.length === 0) {\n        throw new Error(\"Warnings must include log arguments\");\n      }\n\n      var warning = data[0];\n\n      if (typeof warning !== 'string') {\n        throw new TypeError(\"The log argument for a warning must be a string\");\n      }\n\n      var lines = warning.split('\\n');\n\n      if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n        data[0] = lines[0];\n      }\n    }\n\n    var {\n      body,\n      includesStack\n    } = yield LogSerialization.serializeLogDataAsync(data, level);\n\n    _logQueue.push(_objectSpread({\n      count: _logCounter++,\n      level,\n      body,\n      includesStack\n    }, additionalFields));\n\n    _sendRemoteLogsAsync().catch(error => {\n      setImmediate(() => {\n        throw error;\n      });\n    });\n  });\n  return _enqueueRemoteLogAsync.apply(this, arguments);\n}\n\nfunction _sendRemoteLogsAsync() {\n  return _sendRemoteLogsAsync2.apply(this, arguments);\n}\n\nfunction _sendRemoteLogsAsync2() {\n  _sendRemoteLogsAsync2 = _asyncToGenerator(function* () {\n    if (_isSendingLogs || !_logQueue.length) {\n      return;\n    }\n\n    var batch = _logQueue.splice(0);\n\n    var {\n      logUrl\n    } = Constants.manifest;\n    invariant(typeof logUrl === 'string', 'The Expo project manifest must specify `logUrl`');\n    _isSendingLogs = true;\n\n    try {\n      yield _sendNextLogBatchAsync(batch, logUrl);\n    } finally {\n      _isSendingLogs = false;\n    }\n\n    if (_logQueue.length) {\n      return _sendRemoteLogsAsync();\n    } else if (_resolveCompletion) {\n      _resolveCompletion();\n    }\n  });\n  return _sendRemoteLogsAsync2.apply(this, arguments);\n}\n\nfunction _sendNextLogBatchAsync(_x4, _x5) {\n  return _sendNextLogBatchAsync2.apply(this, arguments);\n}\n\nfunction _sendNextLogBatchAsync2() {\n  _sendNextLogBatchAsync2 = _asyncToGenerator(function* (batch, logUrl) {\n    var response;\n\n    try {\n      response = yield fetch(logUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Connection: 'keep-alive',\n          'Proxy-Connection': 'keep-alive',\n          Accept: 'application/json',\n          'Device-Id': Constants.installationId,\n          'Device-Name': Constants.deviceName,\n          'Session-Id': _sessionId\n        },\n        body: JSON.stringify(batch)\n      });\n    } catch (error) {\n      _transportEventEmitter.emit('error', {\n        error\n      });\n\n      return;\n    }\n\n    var success = response.status >= 200 && response.status < 300;\n\n    if (!success) {\n      _transportEventEmitter.emit('error', {\n        error: new Error(\"An HTTP error occurred when sending remote logs\"),\n        response\n      });\n    }\n  });\n  return _sendNextLogBatchAsync2.apply(this, arguments);\n}\n\nfunction addTransportErrorListener(listener) {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data) {\n  var message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener\n};\nexport function __waitForEmptyLogQueueAsync() {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(resolve => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, \"Must not be sending logs at completion\");\n      invariant(!_logQueue.length, \"Log queue must be empty at completion\");\n      _completionPromise = null;\n      _resolveCompletion = null;\n      resolve();\n    };\n  });\n  return _completionPromise;\n}","map":{"version":3,"sources":["../../src/logs/RemoteLogging.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,SAAP,MAAsB,gBAAtB;AACA,SAAS,YAAT,QAAgD,WAAhD;AACA,OAAO,SAAP,MAAsB,WAAtB;AACA,OAAO,IAAP,MAAiB,SAAjB;AAEA,OAAO,gBAAP;;AAuBA,IAAM,UAAU,GAAG,IAAI,CAAC,MAAL,GAAc,QAAd,EAAnB;;AACA,IAAM,SAAS,GAAe,EAA9B;;AACA,IAAM,sBAAsB,GAAG,IAAI,YAAJ,EAA/B;;AAEA,IAAI,WAAW,GAAG,CAAlB;AACA,IAAI,cAAc,GAAG,KAArB;AACA,IAAI,kBAAkB,GAAyB,IAA/C;AACA,IAAI,kBAAkB,GAAwB,IAA9C;;SAEe,qB;;;;;6CAAf,WACE,KADF,EAEE,gBAFF,EAGE,IAHF,EAGiB;AAEf,QAAI,qBAAqB,CAAC,IAAD,CAAzB,EAAiC;AAE/B,UAAI,IAAI,CAAC,MAAL,KAAgB,CAApB,EAAuB;AACrB,cAAM,IAAI,KAAJ,uCAAN;AACD;;AACD,UAAM,OAAO,GAAG,IAAI,CAAC,CAAD,CAApB;;AACA,UAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,cAAM,IAAI,SAAJ,mDAAN;AACD;;AACD,UAAM,KAAK,GAAG,OAAO,CAAC,KAAR,CAAc,IAAd,CAAd;;AACA,UAAI,KAAK,CAAC,MAAN,GAAe,CAAf,IAAoB,UAAU,IAAV,CAAe,KAAK,CAAC,CAAD,CAApB,CAAxB,EAAkD;AAChD,QAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,KAAK,CAAC,CAAD,CAAf;AACD;AACF;;AAED,QAAI;AAAE,MAAA,IAAF;AAAQ,MAAA;AAAR,cAAgC,gBAAgB,CAAC,qBAAjB,CAAuC,IAAvC,EAA6C,KAA7C,CAApC;;AAEA,IAAA,SAAS,CAAC,IAAV;AACE,MAAA,KAAK,EAAE,WAAW,EADpB;AAEE,MAAA,KAFF;AAGE,MAAA,IAHF;AAIE,MAAA;AAJF,OAKK,gBALL;;AASA,IAAA,oBAAoB,GAAG,KAAvB,CAA6B,KAAK,IAAG;AACnC,MAAA,YAAY,CAAC,MAAK;AAChB,cAAM,KAAN;AACD,OAFW,CAAZ;AAGD,KAJD;AAKD,G;;;;SAEc,oB;;;;;4CAAf,aAAmC;AACjC,QAAI,cAAc,IAAI,CAAC,SAAS,CAAC,MAAjC,EAAyC;AACvC;AACD;;AAID,QAAI,KAAK,GAAG,SAAS,CAAC,MAAV,CAAiB,CAAjB,CAAZ;;AAEA,QAAI;AAAE,MAAA;AAAF,QAAa,SAAS,CAAC,QAA3B;AACA,IAAA,SAAS,CAAC,OAAO,MAAP,KAAkB,QAAnB,EAA6B,iDAA7B,CAAT;AAEA,IAAA,cAAc,GAAG,IAAjB;;AACA,QAAI;AACF,YAAM,sBAAsB,CAAC,KAAD,EAAQ,MAAR,CAA5B;AACD,KAFD,SAEU;AACR,MAAA,cAAc,GAAG,KAAjB;AACD;;AAED,QAAI,SAAS,CAAC,MAAd,EAAsB;AACpB,aAAO,oBAAoB,EAA3B;AACD,KAFD,MAEO,IAAI,kBAAJ,EAAwB;AAC7B,MAAA,kBAAkB;AACnB;AACF,G;;;;SAEc,sB;;;;;8CAAf,WAAsC,KAAtC,EAAyD,MAAzD,EAAuE;AACrE,QAAI,QAAJ;;AACA,QAAI;AACF,MAAA,QAAQ,SAAS,KAAK,CAAC,MAAD,EAAS;AAC7B,QAAA,MAAM,EAAE,MADqB;AAE7B,QAAA,OAAO,EAAE;AACP,0BAAgB,kBADT;AAEP,UAAA,UAAU,EAAE,YAFL;AAGP,8BAAoB,YAHb;AAIP,UAAA,MAAM,EAAE,kBAJD;AAKP,uBAAa,SAAS,CAAC,cALhB;AAMP,yBAAe,SAAS,CAAC,UANlB;AAOP,wBAAc;AAPP,SAFoB;AAW7B,QAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,KAAf;AAXuB,OAAT,CAAtB;AAaD,KAdD,CAcE,OAAO,KAAP,EAAc;AACd,MAAA,sBAAsB,CAAC,IAAvB,CAA4B,OAA5B,EAAqC;AAAE,QAAA;AAAF,OAArC;;AACA;AACD;;AAED,QAAI,OAAO,GAAG,QAAQ,CAAC,MAAT,IAAmB,GAAnB,IAA0B,QAAQ,CAAC,MAAT,GAAkB,GAA1D;;AACA,QAAI,CAAC,OAAL,EAAc;AACZ,MAAA,sBAAsB,CAAC,IAAvB,CAA4B,OAA5B,EAAqC;AACnC,QAAA,KAAK,EAAE,IAAI,KAAJ,mDAD4B;AAEnC,QAAA;AAFmC,OAArC;AAID;AACF,G;;;;AAED,SAAS,yBAAT,CAAmC,QAAnC,EAAmE;AACjE,SAAO,sBAAsB,CAAC,WAAvB,CAAmC,OAAnC,EAA4C,QAA5C,CAAP;AACD;;AAED,SAAS,qBAAT,CAA+B,IAA/B,EAA8C;AAE5C,MAAI,OAAO,GAAG,IAAI,CAAC,CAAD,CAAlB;AACA,SAAO,IAAI,CAAC,MAAL,KAAgB,CAAhB,IAAqB,OAAO,OAAP,KAAmB,QAAxC,IAAoD,OAAO,CAAC,UAAR,CAAmB,WAAnB,CAA3D;AACD;;AAED,eAAe;AACb,EAAA,qBADa;AAEb,EAAA;AAFa,CAAf;AASA,OAAM,SAAU,2BAAV,GAAqC;AACzC,MAAI,kBAAJ,EAAwB;AACtB,WAAO,kBAAP;AACD;;AAED,MAAI,CAAC,cAAD,IAAmB,CAAC,SAAS,CAAC,MAAlC,EAA0C;AACxC,WAAO,OAAO,CAAC,OAAR,EAAP;AACD;;AAED,EAAA,kBAAkB,GAAG,IAAI,OAAJ,CAAY,OAAO,IAAG;AACzC,IAAA,kBAAkB,GAAG,MAAK;AACxB,MAAA,SAAS,CAAC,CAAC,cAAF,2CAAT;AACA,MAAA,SAAS,CAAC,CAAC,SAAS,CAAC,MAAZ,0CAAT;AAEA,MAAA,kBAAkB,GAAG,IAArB;AACA,MAAA,kBAAkB,GAAG,IAArB;AAEA,MAAA,OAAO;AACR,KARD;AASD,GAVoB,CAArB;AAWA,SAAO,kBAAP;AACD","sourcesContent":["import Constants from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport UUID from 'uuid-js';\n\nimport LogSerialization from './LogSerialization';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ntype LogEntry = {\n  count: number;\n  level: LogLevel;\n  body: LogData[];\n  includesStack: boolean;\n  groupDepth?: number;\n} & LogEntryFields;\n\nexport type LogEntryFields = {\n  shouldHide?: boolean;\n  groupDepth?: number;\n  groupCollapsed?: boolean;\n};\n\nexport type LogData = string | LogErrorData;\nexport type LogErrorData = { message: string; stack: string };\n\ntype TransportErrorListener = (event: { error: Error; response?: Response }) => void;\n\nconst _sessionId = UUID.create().toString();\nconst _logQueue: LogEntry[] = [];\nconst _transportEventEmitter = new EventEmitter();\n\nlet _logCounter = 0;\nlet _isSendingLogs = false;\nlet _completionPromise: Promise<void> | null = null;\nlet _resolveCompletion: (() => void) | null = null;\n\nasync function enqueueRemoteLogAsync(\n  level: LogLevel,\n  additionalFields: LogEntryFields,\n  data: unknown[]\n): Promise<void> {\n  if (_isReactNativeWarning(data)) {\n    // Remove the stack trace from the warning message since we'll capture our own\n    if (data.length === 0) {\n      throw new Error(`Warnings must include log arguments`);\n    }\n    const warning = data[0];\n    if (typeof warning !== 'string') {\n      throw new TypeError(`The log argument for a warning must be a string`);\n    }\n    const lines = warning.split('\\n');\n    if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n      data[0] = lines[0];\n    }\n  }\n\n  let { body, includesStack } = await LogSerialization.serializeLogDataAsync(data, level);\n\n  _logQueue.push({\n    count: _logCounter++,\n    level,\n    body,\n    includesStack,\n    ...additionalFields,\n  });\n\n  // Send the logs asynchronously (system errors are emitted with transport error events) and throw an uncaught error\n  _sendRemoteLogsAsync().catch(error => {\n    setImmediate(() => {\n      throw error;\n    });\n  });\n}\n\nasync function _sendRemoteLogsAsync(): Promise<void> {\n  if (_isSendingLogs || !_logQueue.length) {\n    return;\n  }\n\n  // Our current transport policy is to send all of the pending log messages in one batch. If we opt\n  // for another policy (ex: throttling) this is where to to implement it.\n  let batch = _logQueue.splice(0);\n\n  let { logUrl } = Constants.manifest;\n  invariant(typeof logUrl === 'string', 'The Expo project manifest must specify `logUrl`');\n\n  _isSendingLogs = true;\n  try {\n    await _sendNextLogBatchAsync(batch, logUrl);\n  } finally {\n    _isSendingLogs = false;\n  }\n\n  if (_logQueue.length) {\n    return _sendRemoteLogsAsync();\n  } else if (_resolveCompletion) {\n    _resolveCompletion();\n  }\n}\n\nasync function _sendNextLogBatchAsync(batch: LogEntry[], logUrl: string): Promise<void> {\n  let response;\n  try {\n    response = await fetch(logUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Connection: 'keep-alive',\n        'Proxy-Connection': 'keep-alive',\n        Accept: 'application/json',\n        'Device-Id': Constants.installationId,\n        'Device-Name': Constants.deviceName,\n        'Session-Id': _sessionId,\n      },\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    _transportEventEmitter.emit('error', { error });\n    return;\n  }\n\n  let success = response.status >= 200 && response.status < 300;\n  if (!success) {\n    _transportEventEmitter.emit('error', {\n      error: new Error(`An HTTP error occurred when sending remote logs`),\n      response,\n    });\n  }\n}\n\nfunction addTransportErrorListener(listener: TransportErrorListener): EventSubscription {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data: unknown[]): boolean {\n  // NOTE: RN does the same thing internally for YellowBox\n  let message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener,\n};\n\n/**\n * Returns a promise that resolves when all entries in the log queue have been sent. This method is\n * intended for testing only.\n */\nexport function __waitForEmptyLogQueueAsync(): Promise<void> {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(resolve => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n\n      _completionPromise = null;\n      _resolveCompletion = null;\n\n      resolve();\n    };\n  });\n  return _completionPromise;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}