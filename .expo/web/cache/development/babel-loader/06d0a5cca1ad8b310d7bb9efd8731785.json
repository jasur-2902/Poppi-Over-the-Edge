{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport * as TaskManager from 'expo-task-manager';\nimport { UnavailabilityError } from '@unimodules/core';\nimport { Platform, NativeModulesProxy } from '@unimodules/core';\nvar {\n  ExpoBackgroundFetch\n} = NativeModulesProxy;\nvar BackgroundFetchResult;\n\n(function (BackgroundFetchResult) {\n  BackgroundFetchResult[BackgroundFetchResult[\"NoData\"] = 1] = \"NoData\";\n  BackgroundFetchResult[BackgroundFetchResult[\"NewData\"] = 2] = \"NewData\";\n  BackgroundFetchResult[BackgroundFetchResult[\"Failed\"] = 3] = \"Failed\";\n})(BackgroundFetchResult || (BackgroundFetchResult = {}));\n\nvar BackgroundFetchStatus;\n\n(function (BackgroundFetchStatus) {\n  BackgroundFetchStatus[BackgroundFetchStatus[\"Denied\"] = 1] = \"Denied\";\n  BackgroundFetchStatus[BackgroundFetchStatus[\"Restricted\"] = 2] = \"Restricted\";\n  BackgroundFetchStatus[BackgroundFetchStatus[\"Available\"] = 3] = \"Available\";\n})(BackgroundFetchStatus || (BackgroundFetchStatus = {}));\n\nexport function getStatusAsync() {\n  return _getStatusAsync.apply(this, arguments);\n}\n\nfunction _getStatusAsync() {\n  _getStatusAsync = _asyncToGenerator(function* () {\n    if (Platform.OS !== 'ios') {\n      return BackgroundFetchStatus.Available;\n    }\n\n    return ExpoBackgroundFetch.getStatusAsync();\n  });\n  return _getStatusAsync.apply(this, arguments);\n}\n\nexport function setMinimumIntervalAsync(_x) {\n  return _setMinimumIntervalAsync.apply(this, arguments);\n}\n\nfunction _setMinimumIntervalAsync() {\n  _setMinimumIntervalAsync = _asyncToGenerator(function* (minimumInterval) {\n    if (Platform.OS !== 'ios') {\n      return;\n    }\n\n    yield ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n  });\n  return _setMinimumIntervalAsync.apply(this, arguments);\n}\n\nexport function registerTaskAsync(_x2) {\n  return _registerTaskAsync.apply(this, arguments);\n}\n\nfunction _registerTaskAsync() {\n  _registerTaskAsync = _asyncToGenerator(function* (taskName) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!ExpoBackgroundFetch.registerTaskAsync) {\n      throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n    }\n\n    if (!TaskManager.isTaskDefined(taskName)) {\n      throw new Error(\"Task '\".concat(taskName, \"' is not defined. You must define a task using TaskManager.defineTask before registering.\"));\n    }\n\n    yield ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n  });\n  return _registerTaskAsync.apply(this, arguments);\n}\n\nexport function unregisterTaskAsync(_x3) {\n  return _unregisterTaskAsync.apply(this, arguments);\n}\n\nfunction _unregisterTaskAsync() {\n  _unregisterTaskAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n      throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n    }\n\n    yield ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n  });\n  return _unregisterTaskAsync.apply(this, arguments);\n}\n\nexport { BackgroundFetchResult as Result, BackgroundFetchStatus as Status };","map":{"version":3,"sources":["../src/BackgroundFetch.ts"],"names":[],"mappings":";;;;AAAA,OAAO,KAAK,WAAZ,MAA6B,mBAA7B;AACA,SAAS,mBAAT,QAAoC,kBAApC;AACA,SAAS,QAAT,EAAmB,kBAAnB,QAA6C,kBAA7C;AAEA,IAAM;AAAE,EAAA;AAAF,IAA0B,kBAAhC;AAEA,IAAK,qBAAL;;AAAA,CAAA,UAAK,qBAAL,EAA0B;AACxB,EAAA,qBAAA,CAAA,qBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACD,CAJD,EAAK,qBAAqB,KAArB,qBAAqB,GAAA,EAAA,CAA1B;;AAMA,IAAK,qBAAL;;AAAA,CAAA,UAAK,qBAAL,EAA0B;AACxB,EAAA,qBAAA,CAAA,qBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACA,EAAA,qBAAA,CAAA,qBAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACD,CAJD,EAAK,qBAAqB,KAArB,qBAAqB,GAAA,EAAA,CAA1B;;AAYA,gBAAsB,cAAtB;AAAA;AAAA;;;sCAAO,aAA6B;AAClC,QAAI,QAAQ,CAAC,EAAT,KAAgB,KAApB,EAA2B;AACzB,aAAO,qBAAqB,CAAC,SAA7B;AACD;;AACD,WAAO,mBAAmB,CAAC,cAApB,EAAP;AACD,G;;;;AAED,gBAAsB,uBAAtB;AAAA;AAAA;;;+CAAO,WAAuC,eAAvC,EAA8D;AACnE,QAAI,QAAQ,CAAC,EAAT,KAAgB,KAApB,EAA2B;AACzB;AACD;;AACD,UAAM,mBAAmB,CAAC,uBAApB,CAA4C,eAA5C,CAAN;AACD,G;;;;AAED,gBAAsB,iBAAtB;AAAA;AAAA;;;yCAAO,WAAiC,QAAjC,EAAuF;AAAA,QAApC,OAAoC,uEAAF,EAAE;;AAC5F,QAAI,CAAC,mBAAmB,CAAC,iBAAzB,EAA4C;AAC1C,YAAM,IAAI,mBAAJ,CAAwB,iBAAxB,EAA2C,mBAA3C,CAAN;AACD;;AACD,QAAI,CAAC,WAAW,CAAC,aAAZ,CAA0B,QAA1B,CAAL,EAA0C;AACxC,YAAM,IAAI,KAAJ,iBACK,QADL,+FAAN;AAGD;;AACD,UAAM,mBAAmB,CAAC,iBAApB,CAAsC,QAAtC,EAAgD,OAAhD,CAAN;AACD,G;;;;AAED,gBAAsB,mBAAtB;AAAA;AAAA;;;2CAAO,WAAmC,QAAnC,EAAmD;AACxD,QAAI,CAAC,mBAAmB,CAAC,mBAAzB,EAA8C;AAC5C,YAAM,IAAI,mBAAJ,CAAwB,iBAAxB,EAA2C,qBAA3C,CAAN;AACD;;AACD,UAAM,mBAAmB,CAAC,mBAApB,CAAwC,QAAxC,CAAN;AACD,G;;;;AAED,SACE,qBAAqB,IAAI,MAD3B,EAEE,qBAAqB,IAAI,MAF3B","sourcesContent":["import * as TaskManager from 'expo-task-manager';\nimport { UnavailabilityError } from '@unimodules/core';\nimport { Platform, NativeModulesProxy } from '@unimodules/core';\n\nconst { ExpoBackgroundFetch } = NativeModulesProxy;\n\nenum BackgroundFetchResult {\n  NoData = 1,\n  NewData = 2,\n  Failed = 3,\n}\n\nenum BackgroundFetchStatus {\n  Denied = 1,\n  Restricted = 2,\n  Available = 3,\n}\n\ninterface BackgroundFetchOptions {\n  minimumInterval?: number;\n  stopOnTerminate?: boolean;\n  startOnBoot?: boolean;\n}\n\nexport async function getStatusAsync(): Promise<BackgroundFetchStatus | null> {\n  if (Platform.OS !== 'ios') {\n    return BackgroundFetchStatus.Available;\n  }\n  return ExpoBackgroundFetch.getStatusAsync();\n}\n\nexport async function setMinimumIntervalAsync(minimumInterval: number): Promise<void> {\n  if (Platform.OS !== 'ios') {\n    return;\n  }\n  await ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n}\n\nexport async function registerTaskAsync(taskName: string, options: BackgroundFetchOptions = {}): Promise<void> {\n  if (!ExpoBackgroundFetch.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync')\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  await ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync')\n  }\n  await ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n}\n\nexport {\n  BackgroundFetchResult as Result,\n  BackgroundFetchStatus as Status,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}