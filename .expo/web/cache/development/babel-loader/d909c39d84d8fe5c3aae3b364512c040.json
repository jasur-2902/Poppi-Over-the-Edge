{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { EventEmitter, Platform } from '@unimodules/core';\nexport default class DeviceSensor {\n  constructor(nativeSensorModule, nativeEventName) {\n    this._nativeModule = nativeSensorModule;\n    this._nativeEmitter = new EventEmitter(nativeSensorModule);\n    this._nativeEventName = nativeEventName;\n    this._listenerCount = 0;\n  }\n\n  addListener(listener) {\n    var subscription = this._nativeEmitter.addListener(this._nativeEventName, listener);\n\n    subscription.remove = () => this.removeSubscription(subscription);\n\n    this._listenerCount++;\n    return subscription;\n  }\n\n  hasListeners() {\n    return this._listenerCount > 0;\n  }\n\n  getListenerCount() {\n    return this._listenerCount;\n  }\n\n  removeAllListeners() {\n    this._listenerCount = 0;\n\n    this._nativeEmitter.removeAllListeners(this._nativeEventName);\n  }\n\n  removeSubscription(subscription) {\n    this._listenerCount--;\n\n    this._nativeEmitter.removeSubscription(subscription);\n  }\n\n  setUpdateInterval(intervalMs) {\n    if (!this._nativeModule.setUpdateInterval) {\n      console.warn(\"expo-sensors: setUpdateInterval() is not supported on \".concat(Platform.OS));\n    } else {\n      this._nativeModule.setUpdateInterval(intervalMs);\n    }\n  }\n\n  isAvailableAsync() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this._nativeModule.isAvailableAsync) {\n        return false;\n      } else {\n        return yield _this._nativeModule.isAvailableAsync();\n      }\n    })();\n  }\n\n}","map":{"version":3,"sources":["../src/DeviceSensor.ts"],"names":[],"mappings":";;;;AAAA,SAAS,YAAT,EAAqC,QAArC,QAAqD,kBAArD;AAUA,eAAc,MAAO,YAAP,CAAmB;AAM/B,EAAA,WAAA,CAAY,kBAAZ,EAAoD,eAApD,EAA2E;AACzE,SAAK,aAAL,GAAqB,kBAArB;AACA,SAAK,cAAL,GAAsB,IAAI,YAAJ,CAAiB,kBAAjB,CAAtB;AACA,SAAK,gBAAL,GAAwB,eAAxB;AACA,SAAK,cAAL,GAAsB,CAAtB;AACD;;AAED,EAAA,WAAW,CAAC,QAAD,EAAsB;AAC/B,QAAI,YAAY,GAAG,KAAK,cAAL,CAAoB,WAApB,CAAgC,KAAK,gBAArC,EAAuD,QAAvD,CAAnB;;AACA,IAAA,YAAY,CAAC,MAAb,GAAsB,MAAM,KAAK,kBAAL,CAAwB,YAAxB,CAA5B;;AACA,SAAK,cAAL;AACA,WAAO,YAAP;AACD;;AAED,EAAA,YAAY,GAAA;AACV,WAAO,KAAK,cAAL,GAAsB,CAA7B;AACD;;AAED,EAAA,gBAAgB,GAAA;AACd,WAAO,KAAK,cAAZ;AACD;;AAED,EAAA,kBAAkB,GAAA;AAChB,SAAK,cAAL,GAAsB,CAAtB;;AACA,SAAK,cAAL,CAAoB,kBAApB,CAAuC,KAAK,gBAA5C;AACD;;AAED,EAAA,kBAAkB,CAAC,YAAD,EAA2B;AAC3C,SAAK,cAAL;;AACA,SAAK,cAAL,CAAoB,kBAApB,CAAuC,YAAvC;AACD;;AAED,EAAA,iBAAiB,CAAC,UAAD,EAAmB;AAClC,QAAI,CAAC,KAAK,aAAL,CAAmB,iBAAxB,EAA2C;AACzC,MAAA,OAAO,CAAC,IAAR,iEAAsE,QAAQ,CAAC,EAA/E;AACD,KAFD,MAEO;AACL,WAAK,aAAL,CAAmB,iBAAnB,CAAqC,UAArC;AACD;AACF;;AACK,EAAA,gBAAN,GAAsB;AAAA;;AAAA;AACpB,UAAI,CAAC,KAAI,CAAC,aAAL,CAAmB,gBAAxB,EAA0C;AACxC,eAAO,KAAP;AACD,OAFD,MAEO;AACL,qBAAa,KAAI,CAAC,aAAL,CAAmB,gBAAnB,EAAb;AACD;AALmB;AAMrB;;AAnD8B","sourcesContent":["import { EventEmitter, Subscription, Platform } from '@unimodules/core';\n\ntype Listener<E> = (event: E) => void;\n\ntype NativeSensorModule = any;\n\n/**\n * A base class for subscribable sensors. The events emitted by this class are measurements\n * specified by the parameter type `M`.\n */\nexport default class DeviceSensor<M> {\n  _nativeModule: NativeSensorModule;\n  _nativeEmitter: EventEmitter;\n  _nativeEventName: string;\n  _listenerCount: number;\n\n  constructor(nativeSensorModule: NativeSensorModule, nativeEventName: string) {\n    this._nativeModule = nativeSensorModule;\n    this._nativeEmitter = new EventEmitter(nativeSensorModule);\n    this._nativeEventName = nativeEventName;\n    this._listenerCount = 0;\n  }\n\n  addListener(listener: Listener<M>): Subscription {\n    let subscription = this._nativeEmitter.addListener(this._nativeEventName, listener);\n    subscription.remove = () => this.removeSubscription(subscription);\n    this._listenerCount++;\n    return subscription;\n  }\n\n  hasListeners(): boolean {\n    return this._listenerCount > 0;\n  }\n\n  getListenerCount(): number {\n    return this._listenerCount;\n  }\n\n  removeAllListeners(): void {\n    this._listenerCount = 0;\n    this._nativeEmitter.removeAllListeners(this._nativeEventName);\n  }\n\n  removeSubscription(subscription: Subscription): void {\n    this._listenerCount--;\n    this._nativeEmitter.removeSubscription(subscription);\n  }\n\n  setUpdateInterval(intervalMs: number): void {\n    if (!this._nativeModule.setUpdateInterval) {\n      console.warn(`expo-sensors: setUpdateInterval() is not supported on ${Platform.OS}`);\n    } else {\n      this._nativeModule.setUpdateInterval(intervalMs);\n    }\n  }\n  async isAvailableAsync(): Promise<boolean> {\n    if (!this._nativeModule.isAvailableAsync) {\n      return false;\n    } else {\n      return await this._nativeModule.isAvailableAsync();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}