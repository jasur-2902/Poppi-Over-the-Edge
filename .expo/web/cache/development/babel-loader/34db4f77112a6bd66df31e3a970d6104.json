{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { getSourceAndEncodeAsync, formatDataAsUrl, isDataUrl, getMimeTypeFromSource } from \"./Utils.web\";\nimport { batchProcessAllSourcesAsync } from \"./ProcessSources.web\";\nexport function processAllImagesAsync(_x) {\n  return _processAllImagesAsync.apply(this, arguments);\n}\n\nfunction _processAllImagesAsync() {\n  _processAllImagesAsync = _asyncToGenerator(function* (element) {\n    if (!(element instanceof HTMLElement)) {\n      return;\n    }\n\n    yield processAndMutateNodeBackgroundImageAsync(element);\n\n    if (element instanceof HTMLImageElement) {\n      yield loadNewImageAsync(element);\n    } else {\n      var children = Array.from(element.childNodes);\n      yield Promise.all(children.map(child => batchProcessAllSourcesAsync(child)));\n    }\n  });\n  return _processAllImagesAsync.apply(this, arguments);\n}\n\nfunction processAndMutateNodeBackgroundImageAsync(_x2) {\n  return _processAndMutateNodeBackgroundImageAsync.apply(this, arguments);\n}\n\nfunction _processAndMutateNodeBackgroundImageAsync() {\n  _processAndMutateNodeBackgroundImageAsync = _asyncToGenerator(function* (element) {\n    var background = element.style.getPropertyValue('background');\n\n    if (background) {\n      var backgroundPropertyValue = yield batchProcessAllSourcesAsync(background);\n      var currentElementBackgroundPriority = element.style.getPropertyPriority('background');\n      element.style.setProperty('background', backgroundPropertyValue, currentElementBackgroundPriority);\n    }\n  });\n  return _processAndMutateNodeBackgroundImageAsync.apply(this, arguments);\n}\n\nfunction loadNewImageAsync(_x3) {\n  return _loadNewImageAsync.apply(this, arguments);\n}\n\nfunction _loadNewImageAsync() {\n  _loadNewImageAsync = _asyncToGenerator(function* (element) {\n    if (isDataUrl(element.src)) {\n      return;\n    }\n\n    var data = yield getSourceAndEncodeAsync(element.src);\n    var dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(element.src));\n    return new Promise((resolve, reject) => {\n      element.onload = () => resolve();\n\n      element.onerror = () => {\n        reject(\"Image could not be loaded \".concat(element.src));\n      };\n\n      element.src = dataUrl;\n    });\n  });\n  return _loadNewImageAsync.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/takeSnapshotAsync/Images.web.ts"],"names":[],"mappings":";;;;AAAA,SACE,uBADF,EAEE,eAFF,EAGE,SAHF,EAIE,qBAJF;AAOA,SAAS,2BAAT;AAEA,gBAAsB,qBAAtB;AAAA;AAAA;;;6CAAO,WAAqC,OAArC,EAAyD;AAC9D,QAAI,EAAE,OAAO,YAAY,WAArB,CAAJ,EAAuC;AACrC;AACD;;AAED,UAAM,wCAAwC,CAAC,OAAD,CAA9C;;AAEA,QAAI,OAAO,YAAY,gBAAvB,EAAyC;AACvC,YAAM,iBAAiB,CAAC,OAAD,CAAvB;AACD,KAFD,MAEO;AACL,UAAM,QAAQ,GAAU,KAAK,CAAC,IAAN,CAAW,OAAO,CAAC,UAAnB,CAAxB;AACA,YAAM,OAAO,CAAC,GAAR,CAAY,QAAQ,CAAC,GAAT,CAAa,KAAK,IAAI,2BAA2B,CAAC,KAAD,CAAjD,CAAZ,CAAN;AACD;AACF,G;;;;SAEc,wC;;;;;gEAAf,WAAwD,OAAxD,EAA4E;AAC1E,QAAM,UAAU,GAAG,OAAO,CAAC,KAAR,CAAc,gBAAd,CAA+B,YAA/B,CAAnB;;AACA,QAAI,UAAJ,EAAgB;AACd,UAAM,uBAAuB,SAAS,2BAA2B,CAAC,UAAD,CAAjE;AACA,UAAM,gCAAgC,GAAG,OAAO,CAAC,KAAR,CAAc,mBAAd,CAAkC,YAAlC,CAAzC;AACA,MAAA,OAAO,CAAC,KAAR,CAAc,WAAd,CACE,YADF,EAEE,uBAFF,EAGE,gCAHF;AAKD;AACF,G;;;;SAEc,iB;;;;;yCAAf,WAAiC,OAAjC,EAA0D;AACxD,QAAI,SAAS,CAAC,OAAO,CAAC,GAAT,CAAb,EAA4B;AAC1B;AACD;;AAED,QAAM,IAAI,SAAS,uBAAuB,CAAC,OAAO,CAAC,GAAT,CAA1C;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,IAAD,EAAO,qBAAqB,CAAC,OAAO,CAAC,GAAT,CAA5B,CAA/B;AACA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACrC,MAAA,OAAO,CAAC,MAAR,GAAiB,MAAM,OAAO,EAA9B;;AACA,MAAA,OAAO,CAAC,OAAR,GAAkB,MAAK;AACrB,QAAA,MAAM,qCAA8B,OAAO,CAAC,GAAtC,EAAN;AACD,OAFD;;AAGA,MAAA,OAAO,CAAC,GAAR,GAAc,OAAd;AACD,KANM,CAAP;AAOD,G","sourcesContent":["import {\n  getSourceAndEncodeAsync,\n  formatDataAsUrl,\n  isDataUrl,\n  getMimeTypeFromSource,\n} from './Utils.web';\n\nimport { batchProcessAllSourcesAsync } from './ProcessSources.web';\n\nexport async function processAllImagesAsync(element: HTMLElement): Promise<void> {\n  if (!(element instanceof HTMLElement)) {\n    return;\n  }\n\n  await processAndMutateNodeBackgroundImageAsync(element);\n\n  if (element instanceof HTMLImageElement) {\n    await loadNewImageAsync(element);\n  } else {\n    const children: any[] = Array.from(element.childNodes);\n    await Promise.all(children.map(child => batchProcessAllSourcesAsync(child)));\n  }\n}\n\nasync function processAndMutateNodeBackgroundImageAsync(element: HTMLElement): Promise<void> {\n  const background = element.style.getPropertyValue('background');\n  if (background) {\n    const backgroundPropertyValue = await batchProcessAllSourcesAsync(background);\n    const currentElementBackgroundPriority = element.style.getPropertyPriority('background');\n    element.style.setProperty(\n      'background',\n      backgroundPropertyValue,\n      currentElementBackgroundPriority\n    );\n  }\n}\n\nasync function loadNewImageAsync(element: HTMLImageElement): Promise<any> {\n  if (isDataUrl(element.src)) {\n    return;\n  }\n\n  const data = await getSourceAndEncodeAsync(element.src);\n  const dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(element.src));\n  return new Promise((resolve, reject) => {\n    element.onload = () => resolve();\n    element.onerror = () => {\n      reject(`Image could not be loaded ${element.src}`);\n    };\n    element.src = dataUrl;\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}