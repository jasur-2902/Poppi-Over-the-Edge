{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\jshukurov\\\\Desktop\\\\Poppi Over The Edge\\\\Poppi-Over-the-Edge-master\\\\node_modules\\\\expo-camera\\\\build\\\\ExponentCamera.web.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport CameraModule from \"./CameraModule/CameraModule\";\nimport CameraManager from \"./ExponentCameraManager.web\";\nexport default class ExponentCamera extends React.Component {\n  constructor() {\n    var _this;\n\n    super(...arguments);\n    _this = this;\n    this.state = {\n      type: null\n    };\n\n    this._updateCameraProps = function () {\n      var _ref2 = _asyncToGenerator(function* (_ref) {\n        var {\n          type,\n          zoom,\n          pictureSize,\n          flashMode,\n          autoFocus,\n          whiteBalance\n        } = _ref;\n        var {\n          camera\n        } = _this;\n\n        if (!camera) {\n          return;\n        }\n\n        yield Promise.all([camera.setTypeAsync(type), camera.setPictureSize(pictureSize), camera.setZoomAsync(zoom), camera.setAutoFocusAsync(autoFocus), camera.setWhiteBalanceAsync(whiteBalance), camera.setFlashModeAsync(flashMode), camera.ensureCameraIsRunningAsync()]);\n        var actualCameraType = camera.getActualCameraType();\n\n        if (actualCameraType !== _this.state.type) {\n          _this.setState({\n            type: actualCameraType\n          });\n        }\n      });\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this.getCamera = () => {\n      if (this.camera) {\n        return this.camera;\n      }\n\n      throw new Error('Camera is not defined yet!');\n    };\n\n    this.getAvailablePictureSizes = function () {\n      var _ref3 = _asyncToGenerator(function* (ratio) {\n        var camera = _this.getCamera();\n\n        return camera.getAvailablePictureSizes(ratio);\n      });\n\n      return function (_x2) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    this.takePicture = function () {\n      var _ref4 = _asyncToGenerator(function* (options) {\n        var camera = _this.getCamera();\n\n        return camera.takePicture(_objectSpread({}, options, {\n          onPictureSaved: _this.props.onPictureSaved\n        }));\n      });\n\n      return function (_x3) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n\n    this.resumePreview = _asyncToGenerator(function* () {\n      var camera = _this.getCamera();\n\n      yield camera.resumePreview();\n    });\n\n    this.pausePreview = () => {\n      var camera = this.getCamera();\n      camera.pausePreview();\n    };\n\n    this.onCameraReady = () => {\n      if (this.props.onCameraReady) {\n        this.props.onCameraReady();\n      }\n    };\n\n    this.onMountError = (_ref6) => {\n      var {\n        nativeEvent\n      } = _ref6;\n\n      if (this.props.onMountError) {\n        this.props.onMountError({\n          nativeEvent\n        });\n      }\n    };\n\n    this._setRef = ref => {\n      if (!ref) {\n        this.video = null;\n\n        if (this.camera) {\n          this.camera.unmount();\n          this.camera = undefined;\n        }\n\n        return;\n      }\n\n      this.video = findNodeHandle(ref);\n      this.camera = new CameraModule(ref);\n      this.camera.onCameraReady = this.onCameraReady;\n      this.camera.onMountError = this.onMountError;\n\n      this._updateCameraProps(this.props);\n    };\n  }\n\n  componentWillUnmount() {\n    if (this.camera) {\n      this.camera.unmount();\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this._updateCameraProps(nextProps);\n  }\n\n  render() {\n    var transform = this.state.type === CameraManager.Type.front ? 'rotateY(180deg)' : 'none';\n    var style = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      width: '100%',\n      height: '100%',\n      objectFit: 'cover',\n      transform\n    };\n    return React.createElement(View, {\n      style: [styles.videoWrapper, this.props.style],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 103,\n        columnNumber: 17\n      }\n    }, React.createElement(\"video\", {\n      ref: this._setRef,\n      style: style,\n      autoPlay: true,\n      playsInline: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 104,\n        columnNumber: 9\n      }\n    }), this.props.children);\n  }\n\n}\nvar styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch'\n  }\n});","map":{"version":3,"sources":["../src/ExponentCamera.web.tsx"],"names":[],"mappings":"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","sourcesContent":["import React, { CSSProperties } from 'react';\nimport { findNodeHandle, StyleSheet, View } from 'react-native';\nimport { CapturedPicture, NativeProps, PictureOptions, MountError } from './Camera.types';\nimport CameraModule, { CameraType } from './CameraModule/CameraModule';\nimport CameraManager from './ExponentCameraManager.web';\n\nexport default class ExponentCamera extends React.Component<NativeProps> {\n  video?: number | null;\n  camera?: CameraModule;\n\n  state = { type: null };\n\n  componentWillUnmount() {\n    if (this.camera) {\n      this.camera.unmount();\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this._updateCameraProps(nextProps);\n  }\n\n  _updateCameraProps = async ({\n    type,\n    zoom,\n    pictureSize,\n    flashMode,\n    autoFocus,\n    // focusDepth,\n    whiteBalance,\n  }: NativeProps) => {\n    const { camera } = this;\n    if (!camera) {\n      return;\n    }\n    await Promise.all([\n      camera.setTypeAsync(type as CameraType),\n      camera.setPictureSize(pictureSize as string),\n      camera.setZoomAsync(zoom as number),\n      camera.setAutoFocusAsync(autoFocus as string),\n      camera.setWhiteBalanceAsync(whiteBalance as string),\n      camera.setFlashModeAsync(flashMode as string),\n      camera.ensureCameraIsRunningAsync(),\n    ]);\n    const actualCameraType = camera.getActualCameraType();\n    if (actualCameraType !== this.state.type) {\n      this.setState({ type: actualCameraType });\n    }\n  };\n\n  getCamera = (): CameraModule => {\n    if (this.camera) {\n      return this.camera;\n    }\n    throw new Error('Camera is not defined yet!');\n  };\n\n  getAvailablePictureSizes = async (ratio: string): Promise<string[]> => {\n    const camera = this.getCamera();\n    return camera.getAvailablePictureSizes(ratio);\n  };\n\n  takePicture = async (options: PictureOptions): Promise<CapturedPicture> => {\n    const camera = this.getCamera();\n    return camera.takePicture({\n      ...options,\n      // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n      onPictureSaved: this.props.onPictureSaved,\n    });\n  };\n\n  resumePreview = async (): Promise<void> => {\n    const camera = this.getCamera();\n    await camera.resumePreview();\n  };\n\n  pausePreview = (): void => {\n    const camera = this.getCamera();\n    camera.pausePreview();\n  };\n\n  onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n\n  onMountError = ({ nativeEvent }: { nativeEvent: MountError }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError({ nativeEvent });\n    }\n  };\n\n  _setRef = ref => {\n    if (!ref) {\n      this.video = null;\n      if (this.camera) {\n        this.camera.unmount();\n        this.camera = undefined;\n      }\n      return;\n    }\n    this.video = findNodeHandle(ref);\n    this.camera = new CameraModule(ref);\n    this.camera.onCameraReady = this.onCameraReady;\n    this.camera.onMountError = this.onMountError;\n    this._updateCameraProps(this.props);\n  };\n\n  render() {\n    const transform = this.state.type === CameraManager.Type.front ? 'rotateY(180deg)' : 'none';\n    const style: CSSProperties = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      width: '100%',\n      height: '100%',\n      objectFit: 'cover',\n      transform,\n    };\n\n    return (\n      <View style={[styles.videoWrapper, this.props.style]}>\n        <video ref={this._setRef} style={style} autoPlay playsInline />\n        {this.props.children}\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n  },\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}