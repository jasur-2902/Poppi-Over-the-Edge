{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\jshukurov\\\\Desktop\\\\Poppi Over The Edge\\\\Poppi-Over-the-Edge-master\\\\node_modules\\\\expo-linear-gradient\\\\build\\\\NativeLinearGradient.web.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nvar PI_2 = Math.PI / 2;\nexport default class NativeLinearGradient extends React.PureComponent {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      width: undefined,\n      height: undefined\n    };\n\n    this.onLayout = event => {\n      this.setState({\n        width: event.nativeEvent.layout.width,\n        height: event.nativeEvent.layout.height\n      });\n\n      if (this.props.onLayout) {\n        this.props.onLayout(event);\n      }\n    };\n\n    this.getControlPoints = () => {\n      var {\n        startPoint,\n        endPoint\n      } = this.props;\n      var correctedStartPoint = [0, 0];\n\n      if (Array.isArray(startPoint)) {\n        correctedStartPoint = [startPoint[0] != null ? startPoint[0] : 0.0, startPoint[1] != null ? startPoint[1] : 0.0];\n      }\n\n      var correctedEndPoint = [0.0, 1.0];\n\n      if (Array.isArray(endPoint)) {\n        correctedEndPoint = [endPoint[0] != null ? endPoint[0] : 0.0, endPoint[1] != null ? endPoint[1] : 1.0];\n      }\n\n      return [correctedStartPoint, correctedEndPoint];\n    };\n\n    this.calculateGradientAngleFromControlPoints = () => {\n      var [start, end] = this.getControlPoints();\n      var {\n        width = 1,\n        height = 1\n      } = this.state;\n      start[0] *= width;\n      end[0] *= width;\n      start[1] *= height;\n      end[1] *= height;\n      var py = end[1] - start[1];\n      var px = end[0] - start[0];\n      return 90 + Math.atan2(py, px) * 180 / Math.PI;\n    };\n\n    this.getWebGradientColorStyle = () => {\n      return this.getGradientValues().join(',');\n    };\n\n    this.convertJSColorToGradientSafeColor = (color, index) => {\n      var {\n        locations\n      } = this.props;\n      var hexColor = hexStringFromProcessedColor(color);\n      var output = hexColor;\n\n      if (locations && locations[index]) {\n        var location = Math.max(0, Math.min(1, locations[index]));\n        var percentage = location * 100;\n        output += \" \".concat(percentage, \"%\");\n      }\n\n      return output;\n    };\n\n    this.getGradientValues = () => {\n      return this.props.colors.map(this.convertJSColorToGradientSafeColor);\n    };\n\n    this.getBackgroundImage = () => {\n      return \"linear-gradient(\".concat(this.calculateGradientAngleFromControlPoints(), \"deg, \").concat(this.getWebGradientColorStyle(), \")\");\n    };\n  }\n\n  render() {\n    var _this$props = this.props,\n        {\n      colors,\n      locations,\n      startPoint,\n      endPoint,\n      onLayout,\n      style\n    } = _this$props,\n        props = _objectWithoutProperties(_this$props, [\"colors\", \"locations\", \"startPoint\", \"endPoint\", \"onLayout\", \"style\"]);\n\n    var backgroundImage = this.getBackgroundImage();\n    return React.createElement(View, _extends({\n      style: [style, {\n        backgroundImage\n      }],\n      onLayout: this.onLayout\n    }, props, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 75,\n        columnNumber: 17\n      }\n    }));\n  }\n\n}\n\nfunction hexStringFromProcessedColor(argbColor) {\n  if (argbColor === 0) {\n    return \"rgba(0,0,0,0)\";\n  }\n\n  var hexColorString = argbColor.toString(16);\n  var withoutAlpha = hexColorString.substring(2);\n  var alpha = hexColorString.substring(0, 2);\n  return \"#\".concat(withoutAlpha).concat(alpha);\n}","map":{"version":3,"sources":["../src/NativeLinearGradient.web.tsx"],"names":[],"mappings":"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","sourcesContent":["import React from 'react';\nimport { View } from 'react-native';\n\ntype Props = {\n  colors: number[];\n  locations?: number[] | null;\n  startPoint?: Point | null;\n  endPoint?: Point | null;\n  onLayout?: Function;\n} & React.ComponentProps<typeof View>;\n\ntype State = {\n  width?: number;\n  height?: number;\n};\n\ntype Point = [number, number];\n\nconst PI_2 = Math.PI / 2;\n\nexport default class NativeLinearGradient extends React.PureComponent<Props, State> {\n  state = {\n    width: undefined,\n    height: undefined,\n  };\n\n  onLayout = event => {\n    this.setState({\n      width: event.nativeEvent.layout.width,\n      height: event.nativeEvent.layout.height,\n    });\n    if (this.props.onLayout) {\n      this.props.onLayout(event);\n    }\n  };\n\n  getControlPoints = (): Point[] => {\n    const { startPoint, endPoint } = this.props;\n\n    let correctedStartPoint: Point = [0, 0];\n    if (Array.isArray(startPoint)) {\n      correctedStartPoint = [\n        startPoint[0] != null ? startPoint[0] : 0.0,\n        startPoint[1] != null ? startPoint[1] : 0.0,\n      ];\n    }\n    let correctedEndPoint: Point = [0.0, 1.0];\n    if (Array.isArray(endPoint)) {\n      correctedEndPoint = [\n        endPoint[0] != null ? endPoint[0] : 0.0,\n        endPoint[1] != null ? endPoint[1] : 1.0,\n      ];\n    }\n    return [correctedStartPoint, correctedEndPoint];\n  };\n\n  calculateGradientAngleFromControlPoints = (): number => {\n    const [start, end] = this.getControlPoints();\n    const { width = 1, height = 1 } = this.state;\n    start[0] *= width;\n    end[0] *= width;\n    start[1] *= height;\n    end[1] *= height;\n    const py = end[1] - start[1];\n    const px = end[0] - start[0];\n    return 90 + (Math.atan2(py, px) * 180) / Math.PI;\n  };\n\n  getWebGradientColorStyle = (): string => {\n    return this.getGradientValues().join(',');\n  };\n\n  convertJSColorToGradientSafeColor = (color: number, index: number): string => {\n    const { locations } = this.props;\n    const hexColor = hexStringFromProcessedColor(color);\n    let output = hexColor;\n    if (locations && locations[index]) {\n      const location = Math.max(0, Math.min(1, locations[index]));\n      // Convert 0...1 to 0...100\n      const percentage = location * 100;\n      output += ` ${percentage}%`;\n    }\n    return output;\n  };\n\n  getGradientValues = (): string[] => {\n    return this.props.colors.map(this.convertJSColorToGradientSafeColor);\n  };\n\n  getBackgroundImage = (): string => {\n    return `linear-gradient(${this.calculateGradientAngleFromControlPoints()}deg, ${this.getWebGradientColorStyle()})`;\n  };\n\n  render() {\n    const { colors, locations, startPoint, endPoint, onLayout, style, ...props } = this.props;\n    const backgroundImage = this.getBackgroundImage();\n    // TODO: Bacon: In the future we could consider adding `backgroundRepeat: \"no-repeat\"`. For more browser support.\n    return (\n      <View\n        style={[\n          style,\n          // @ts-ignore: [ts] Property 'backgroundImage' does not exist on type 'ViewStyle'.\n          { backgroundImage },\n        ]}\n        onLayout={this.onLayout}\n        {...props}\n      />\n    );\n  }\n}\n\nfunction hexStringFromProcessedColor(argbColor: number): string {\n  if (argbColor === 0) {\n    return `rgba(0,0,0,0)`;\n  }\n  const hexColorString = argbColor.toString(16);\n  const withoutAlpha = hexColorString.substring(2);\n  const alpha = hexColorString.substring(0, 2);\n  return `#${withoutAlpha}${alpha}`;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}