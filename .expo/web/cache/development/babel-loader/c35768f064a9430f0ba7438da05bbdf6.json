{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\jshukurov\\\\Desktop\\\\Poppi Over The Edge\\\\Poppi-Over-the-Edge-master\\\\node_modules\\\\expo-pixi\\\\lib\\\\components\\\\FilterImage.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport React from 'react';\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport { GLView } from 'expo-gl';\nimport { Asset } from 'expo-asset';\nimport PIXI from \"../Pixi\";\nimport { takeSnapshotAsync } from \"../utils\";\nglobal.__ExpoFilterImageId = global.__ExpoFilterImageId || 0;\n\nfunction centerSprite(sprite, parent) {\n  sprite.x = (parent.width - sprite.width) / 2;\n  sprite.y = (parent.height - sprite.height) / 2;\n}\n\nfunction adjustRatio(sprite, parent, isCover) {\n  var other = side => side === 'width' ? 'height' : 'width';\n\n  var longest;\n\n  if (sprite.width < sprite.height) {\n    longest = isCover ? 'width' : 'height';\n  } else {\n    longest = isCover ? 'height' : 'width';\n  }\n\n  var shortest = other(longest);\n  var ratio = sprite[shortest] / sprite[longest];\n  sprite[longest] = parent[longest];\n  sprite[shortest] = parent[longest] * ratio;\n}\n\nexport default class FilterImage extends React.Component {\n  constructor() {\n    var _this;\n\n    super(...arguments);\n    _this = this;\n\n    this.updateTextureAsync = function () {\n      var _ref = _asyncToGenerator(function* (source) {\n        if (!_this.renderer || !_this.image || !source) {\n          return;\n        }\n\n        var texture = yield PIXI.Texture.fromExpoAsync(source);\n\n        if (source === _this.props.source) {\n          _this.image.texture = texture;\n        }\n\n        _this.renderer._update();\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.updateResizeMode = resizeMode => {\n      if (!this.renderer || !this.image || !resizeMode) {\n        return;\n      }\n\n      var {\n        width,\n        height\n      } = this.renderer;\n      var willInvert = height > width;\n      var cover = resizeMode.toLowerCase() === 'cover';\n\n      if (willInvert) {\n        cover = !cover;\n      }\n\n      adjustRatio(this.image, this.renderer, cover);\n      centerSprite(this.image, this.renderer);\n\n      this.renderer._update();\n    };\n\n    this.updateFilters = filters => {\n      if (!this.renderer || !this.image || !filters) {\n        return;\n      }\n\n      if (!Array.isArray(filters)) {\n        this.image.filters = [filters];\n      } else {\n        this.image.filters = filters;\n      }\n\n      this.renderer._update();\n    };\n\n    this.takeSnapshotAsync = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return takeSnapshotAsync(_this.glView, ...args);\n    };\n\n    this.onLayout = (_ref2) => {\n      var {\n        nativeEvent: {\n          layout: {\n            width,\n            height\n          }\n        }\n      } = _ref2;\n\n      if (this.renderer) {\n        var scale = PixelRatio.get();\n        this.renderer.resize(width * scale, height * scale);\n      }\n\n      this.updateResizeMode(this.props.resizeMode);\n    };\n\n    this.onContextCreate = function () {\n      var _ref3 = _asyncToGenerator(function* (context) {\n        var {\n          filters,\n          resizeMode,\n          source\n        } = _this.props;\n        _this.context = context;\n        _this.stage = new PIXI.Container();\n\n        var getAttributes = context.getContextAttributes || (() => ({}));\n\n        context.getContextAttributes = () => {\n          var contextAttributes = getAttributes();\n          return _objectSpread({}, contextAttributes, {\n            stencil: true\n          });\n        };\n\n        _this.renderer = PIXI.autoDetectRenderer(context.drawingBufferWidth, context.drawingBufferHeight, {\n          context,\n          antialias: true,\n          backgroundColor: 'transparent',\n          transparent: true,\n          autoStart: false\n        });\n        _this.image = yield PIXI.Sprite.fromExpoAsync(source);\n\n        _this.stage.addChild(_this.image);\n\n        _this.renderer._update = () => {\n          _this.renderer.render(_this.stage);\n\n          context.endFrameEXP();\n        };\n\n        _this.updateResizeMode(resizeMode);\n\n        _this.updateFilters(filters);\n\n        _this.props.onReady && _this.props.onReady(context);\n      });\n\n      return function (_x2) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    this.setRef = ref => {\n      this.glView = ref;\n    };\n  }\n\n  componentWillMount() {\n    global.__ExpoFilterImageId++;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    var {\n      props\n    } = this;\n\n    if (nextProps.resizeMode !== props.resizeMode) {\n      this.updateResizeMode(nextProps.resizeMode);\n    }\n\n    if (nextProps.source !== props.source) {\n      this.updateTextureAsync(nextProps.source);\n    }\n\n    if (nextProps.filters !== props.filters) {\n      this.updateFilters(nextProps.filters);\n    }\n\n    return false;\n  }\n\n  render() {\n    return React.createElement(GLView, _extends({\n      onLayout: this.onLayout,\n      key: 'Expo.FilterImage-' + global.__ExpoSketchId,\n      ref: this.setRef\n    }, this.props, {\n      onContextCreate: this.onContextCreate,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163,\n        columnNumber: 7\n      }\n    }));\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/expo-pixi/lib/components/FilterImage.js"],"names":["React","GLView","Asset","PIXI","takeSnapshotAsync","global","__ExpoFilterImageId","centerSprite","sprite","parent","x","width","y","height","adjustRatio","isCover","other","side","longest","shortest","ratio","FilterImage","Component","updateTextureAsync","source","renderer","image","texture","Texture","fromExpoAsync","props","_update","updateResizeMode","resizeMode","willInvert","cover","toLowerCase","updateFilters","filters","Array","isArray","args","glView","onLayout","nativeEvent","layout","scale","PixelRatio","get","resize","onContextCreate","context","stage","Container","getAttributes","getContextAttributes","contextAttributes","stencil","autoDetectRenderer","drawingBufferWidth","drawingBufferHeight","antialias","backgroundColor","transparent","autoStart","Sprite","addChild","render","endFrameEXP","onReady","setRef","ref","componentWillMount","shouldComponentUpdate","nextProps","nextState","__ExpoSketchId"],"mappings":"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","sourcesContent":["//@flow\nimport React from 'react';\nimport { PixelRatio } from 'react-native';\nimport { GLView } from 'expo-gl';\nimport { Asset } from 'expo-asset';\n\nimport PIXI from '../Pixi';\nimport { takeSnapshotAsync } from '../utils';\n\nglobal.__ExpoFilterImageId = global.__ExpoFilterImageId || 0;\n\nfunction centerSprite(sprite: PIXI.Sprite, parent) {\n  sprite.x = (parent.width - sprite.width) / 2;\n  sprite.y = (parent.height - sprite.height) / 2;\n}\n\nfunction adjustRatio(sprite, parent, isCover) {\n  const other = side => (side === 'width' ? 'height' : 'width');\n\n  let longest;\n  if (sprite.width < sprite.height) {\n    longest = isCover ? 'width' : 'height';\n  } else {\n    longest = isCover ? 'height' : 'width';\n  }\n\n  let shortest = other(longest);\n\n  const ratio = sprite[shortest] / sprite[longest];\n  sprite[longest] = parent[longest];\n  sprite[shortest] = parent[longest] * ratio;\n}\n\ntype Props = {\n  source: string | number | Asset,\n  resizeMode: string,\n  filters: Array<PIXI.Filter>,\n};\n\nexport default class FilterImage extends React.Component<Props> {\n  componentWillMount() {\n    global.__ExpoFilterImageId++;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const { props } = this;\n\n    if (nextProps.resizeMode !== props.resizeMode) {\n      this.updateResizeMode(nextProps.resizeMode);\n    }\n    if (nextProps.source !== props.source) {\n      this.updateTextureAsync(nextProps.source);\n    }\n    if (nextProps.filters !== props.filters) {\n      this.updateFilters(nextProps.filters);\n    }\n\n    return false;\n  }\n\n  updateTextureAsync = async source => {\n    if (!this.renderer || !this.image || !source) {\n      return;\n    }\n    const texture = await PIXI.Texture.fromExpoAsync(source);\n    if (source === this.props.source) {\n      this.image.texture = texture;\n    }\n    this.renderer._update();\n  };\n\n  updateResizeMode = resizeMode => {\n    if (!this.renderer || !this.image || !resizeMode) {\n      return;\n    }\n\n    const { width, height } = this.renderer;\n    const willInvert = height > width;\n    let cover = resizeMode.toLowerCase() === 'cover';\n    if (willInvert) {\n      cover = !cover;\n    }\n    adjustRatio(this.image, this.renderer, cover);\n    centerSprite(this.image, this.renderer);\n    this.renderer._update();\n  };\n\n  updateFilters = filters => {\n    if (!this.renderer || !this.image || !filters) {\n      return;\n    }\n    if (!Array.isArray(filters)) {\n      this.image.filters = [filters];\n    } else {\n      this.image.filters = filters;\n    }\n\n    this.renderer._update();\n  };\n\n  takeSnapshotAsync = (...args) => {\n    return takeSnapshotAsync(this.glView, ...args);\n  };\n\n  onLayout = ({\n    nativeEvent: {\n      layout: { width, height },\n    },\n  }) => {\n    if (this.renderer) {\n      const scale = PixelRatio.get();\n      this.renderer.resize(width * scale, height * scale);\n    }\n    this.updateResizeMode(this.props.resizeMode);\n  };\n\n  onContextCreate = async (context: WebGLRenderingContext) => {\n    const { filters, resizeMode, source } = this.props;\n\n    this.context = context;\n    this.stage = new PIXI.Container();\n\n    const getAttributes = context.getContextAttributes || (() => ({}));\n    context.getContextAttributes = () => {\n      const contextAttributes = getAttributes();\n      return {\n        ...contextAttributes,\n        stencil: true,\n      };\n    };\n\n    this.renderer = PIXI.autoDetectRenderer(\n      context.drawingBufferWidth,\n      context.drawingBufferHeight,\n      {\n        context,\n        antialias: true,\n        backgroundColor: 'transparent',\n        transparent: true,\n        autoStart: false,\n      }\n    );\n\n    this.image = await PIXI.Sprite.fromExpoAsync(source);\n    this.stage.addChild(this.image);\n\n    this.renderer._update = () => {\n      this.renderer.render(this.stage);\n      context.endFrameEXP();\n    };\n    this.updateResizeMode(resizeMode);\n    this.updateFilters(filters);\n\n    this.props.onReady && this.props.onReady(context);\n  };\n\n  setRef = ref => {\n    this.glView = ref;\n  };\n\n  render() {\n    return (\n      <GLView\n        onLayout={this.onLayout}\n        key={'Expo.FilterImage-' + global.__ExpoSketchId}\n        ref={this.setRef}\n        {...this.props}\n        onContextCreate={this.onContextCreate}\n      />\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}