{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport Constants from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from \"./symbolicateStackTrace\";\nimport ReactNodeFormatter from \"./format/ReactNodeFormatter\";\nexport var EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nfunction serializeLogDataAsync(_x, _x2) {\n  return _serializeLogDataAsync.apply(this, arguments);\n}\n\nfunction _serializeLogDataAsync() {\n  _serializeLogDataAsync = _asyncToGenerator(function* (data, level) {\n    var serializedValues;\n    var includesStack = false;\n\n    if (_stackTraceLogsSupported()) {\n      if (_isUnhandledPromiseRejection(data, level)) {\n        var rawStack = data[0];\n        var syntheticError = {\n          stack: rawStack\n        };\n        var stack = yield _symbolicateErrorAsync(syntheticError);\n\n        if (!stack.length) {\n          serializedValues = _stringifyLogData(data);\n        } else {\n          var errorMessage = rawStack.split('\\n')[1];\n          serializedValues = [{\n            message: \"[Unhandled promise rejection: \".concat(errorMessage, \"]\"),\n            stack: _formatStack(stack)\n          }];\n          includesStack = true;\n        }\n      } else if (data.length === 1 && data[0] instanceof Error) {\n        var serializedError = yield _serializeErrorAsync(data[0]);\n        serializedValues = [serializedError];\n        includesStack = serializedError.hasOwnProperty('stack');\n      } else if (level === 'warn' || level === 'error') {\n        var error = _captureConsoleStackTrace();\n\n        var _errorMessage = _stringifyLogData(data).join(', ');\n\n        var _serializedError = yield _serializeErrorAsync(error, _errorMessage);\n\n        serializedValues = [_serializedError];\n        includesStack = _serializedError.hasOwnProperty('stack');\n      } else {\n        serializedValues = _stringifyLogData(data);\n      }\n    } else {\n      serializedValues = _stringifyLogData(data);\n    }\n\n    return {\n      body: [...serializedValues],\n      includesStack\n    };\n  });\n  return _serializeLogDataAsync.apply(this, arguments);\n}\n\nfunction _stringifyLogData(data) {\n  return data.map(item => {\n    if (typeof item === 'string') {\n      return item;\n    } else {\n      return prettyFormat(item, {\n        plugins: [ReactNodeFormatter]\n      });\n    }\n  });\n}\n\nfunction _serializeErrorAsync(_x3, _x4) {\n  return _serializeErrorAsync2.apply(this, arguments);\n}\n\nfunction _serializeErrorAsync2() {\n  _serializeErrorAsync2 = _asyncToGenerator(function* (error, message) {\n    if (message == null) {\n      message = error.message;\n    }\n\n    if (!error.stack || !error.stack.length) {\n      return prettyFormat(error);\n    }\n\n    var stack = yield _symbolicateErrorAsync(error);\n\n    var formattedStack = _formatStack(stack);\n\n    return {\n      message,\n      stack: formattedStack\n    };\n  });\n  return _serializeErrorAsync2.apply(this, arguments);\n}\n\nfunction _symbolicateErrorAsync(_x5) {\n  return _symbolicateErrorAsync2.apply(this, arguments);\n}\n\nfunction _symbolicateErrorAsync2() {\n  _symbolicateErrorAsync2 = _asyncToGenerator(function* (error) {\n    var parsedStack = parseErrorStack(error);\n    var symbolicatedStack;\n\n    try {\n      symbolicatedStack = yield symbolicateStackTrace(parsedStack);\n    } catch (error) {\n      return parsedStack;\n    }\n\n    if (!symbolicatedStack) {\n      return parsedStack;\n    }\n\n    return symbolicatedStack.map(_removeProjectRoot);\n  });\n  return _symbolicateErrorAsync2.apply(this, arguments);\n}\n\nfunction _formatStack(stack) {\n  return stack.map(frame => {\n    var line = \"\".concat(frame.file, \":\").concat(frame.lineNumber);\n\n    if (frame.column != null) {\n      line += \":\".concat(frame.column);\n    }\n\n    line += \" in \".concat(frame.methodName);\n    return line;\n  }).join('\\n');\n}\n\nfunction _removeProjectRoot(frame) {\n  var filename = frame.file;\n\n  if (filename == null) {\n    return frame;\n  }\n\n  var projectRoot = _getProjectRoot();\n\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n\n    frame.file = filename;\n  }\n\n  return frame;\n}\n\nfunction _stackTraceLogsSupported() {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data, level) {\n  return level === 'warn' && typeof data[0] === 'string' && /^Possible Unhandled Promise Rejection/.test(data[0]);\n}\n\nfunction _captureConsoleStackTrace() {\n  try {\n    throw new Error();\n  } catch (error) {\n    var stackLines = error.stack.split('\\n');\n    var consoleMethodIndex = stackLines.findIndex(frame => frame.includes(EXPO_CONSOLE_METHOD_NAME));\n\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n\n    return error;\n  }\n}\n\nfunction _getProjectRoot() {\n  return Constants.manifest && Constants.manifest.developer ? Constants.manifest.developer.projectRoot : null;\n}\n\nexport default {\n  serializeLogDataAsync\n};","map":{"version":3,"sources":["../../src/logs/LogSerialization.ts"],"names":[],"mappings":"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","sourcesContent":["import Constants from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack, { StackFrame } from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from './symbolicateStackTrace';\n\nimport { LogData, LogLevel } from './RemoteLogging';\nimport ReactNodeFormatter from './format/ReactNodeFormatter';\n\ntype SerializedData = {\n  body: LogData[];\n  includesStack: boolean;\n};\n\nexport const EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nasync function serializeLogDataAsync(data: unknown[], level: LogLevel): Promise<SerializedData> {\n  let serializedValues: ReadonlyArray<LogData>;\n  let includesStack = false;\n\n  if (_stackTraceLogsSupported()) {\n    if (_isUnhandledPromiseRejection(data, level)) {\n      let rawStack = data[0] as string;\n      let syntheticError = { stack: rawStack };\n      let stack = await _symbolicateErrorAsync(syntheticError as Error);\n\n      if (!stack.length) {\n        serializedValues = _stringifyLogData(data);\n      } else {\n        // NOTE: This doesn't handle error messages with newlines\n        let errorMessage = rawStack.split('\\n')[1];\n        serializedValues = [\n          {\n            message: `[Unhandled promise rejection: ${errorMessage}]`,\n            stack: _formatStack(stack),\n          },\n        ];\n        includesStack = true;\n      }\n    } else if (data.length === 1 && data[0] instanceof Error) {\n      // When there's only one argument to the log function and that argument is an error, we\n      // include the error's stack. If there's more than one argument then we don't include the\n      // stack because it's not easy to display nicely in our current UI.\n\n      let serializedError = await _serializeErrorAsync(data[0] as Error);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else if (level === 'warn' || level === 'error') {\n      // For console.warn and console.error it is usually useful to know the stack that leads to the\n      // warning or error, so we provide this information to help out with debugging\n\n      let error = _captureConsoleStackTrace();\n      // [\"hello\", \"world\"] becomes \"hello, world\"\n      let errorMessage = _stringifyLogData(data).join(', ');\n\n      let serializedError = await _serializeErrorAsync(error, errorMessage);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else {\n      serializedValues = _stringifyLogData(data);\n    }\n  } else {\n    serializedValues = _stringifyLogData(data);\n  }\n\n  return {\n    body: [...serializedValues],\n    includesStack,\n  };\n}\n\nfunction _stringifyLogData(data: unknown[]): string[] {\n  return data.map(item => {\n    if (typeof item === 'string') {\n      return item;\n    } else {\n      return prettyFormat(item, { plugins: [ReactNodeFormatter] });\n    }\n  });\n}\n\nasync function _serializeErrorAsync(error: Error, message?: string): Promise<LogData> {\n  if (message == null) {\n    message = error.message;\n  }\n\n  if (!error.stack || !error.stack.length) {\n    return prettyFormat(error);\n  }\n\n  let stack = await _symbolicateErrorAsync(error);\n  let formattedStack = _formatStack(stack);\n\n  return { message, stack: formattedStack };\n}\n\nasync function _symbolicateErrorAsync(error: Error): Promise<StackFrame[]> {\n  let parsedStack = parseErrorStack(error);\n  let symbolicatedStack: StackFrame[] | null;\n  try {\n    symbolicatedStack = await symbolicateStackTrace(parsedStack);\n  } catch (error) {\n    return parsedStack;\n  }\n\n  // In this context an unsymbolicated stack is better than no stack\n  if (!symbolicatedStack) {\n    return parsedStack;\n  }\n\n  // Clean the stack trace\n  return symbolicatedStack.map(_removeProjectRoot);\n}\n\nfunction _formatStack(stack: StackFrame[]): string {\n  return stack\n    .map(frame => {\n      let line = `${frame.file}:${frame.lineNumber}`;\n      if (frame.column != null) {\n        line += `:${frame.column}`;\n      }\n      line += ` in ${frame.methodName}`;\n      return line;\n    })\n    .join('\\n');\n}\n\nfunction _removeProjectRoot(frame: StackFrame): StackFrame {\n  let filename = frame.file;\n  if (filename == null) {\n    return frame;\n  }\n\n  let projectRoot = _getProjectRoot();\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n    frame.file = filename;\n  }\n\n  return frame;\n}\n\n/**\n * Returns whether the development server that served this project supports logs with a stack trace.\n * Specifically, the version of Expo CLI that includes `projectRoot` in the manifest also accepts\n * payloads of the form:\n *\n * {\n *   includesStack: boolean, body: [{ message: string, stack: string }],\n * }\n */\nfunction _stackTraceLogsSupported(): boolean {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data: unknown[], level: LogLevel): boolean {\n  return (\n    level === 'warn' &&\n    typeof data[0] === 'string' &&\n    /^Possible Unhandled Promise Rejection/.test(data[0] as string)\n  );\n}\n\nfunction _captureConsoleStackTrace(): Error {\n  try {\n    throw new Error();\n  } catch (error) {\n    let stackLines = error.stack.split('\\n');\n    let consoleMethodIndex = stackLines.findIndex(frame =>\n      frame.includes(EXPO_CONSOLE_METHOD_NAME)\n    );\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n    return error;\n  }\n}\n\nfunction _getProjectRoot(): string | null {\n  return Constants.manifest && Constants.manifest.developer\n    ? Constants.manifest.developer.projectRoot\n    : null;\n}\n\nexport default {\n  serializeLogDataAsync,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}