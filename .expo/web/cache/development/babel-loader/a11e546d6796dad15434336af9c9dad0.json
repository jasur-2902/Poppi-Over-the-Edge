{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { UnavailabilityError } from 'expo-errors';\nimport invariant from 'invariant';\nimport ExpoGoogleSignIn from \"./ExpoGoogleSignIn\";\nimport GoogleAuthentication from \"./GoogleAuthentication\";\nimport GoogleIdentity from \"./GoogleIdentity\";\n\nclass GoogleUser extends GoogleIdentity {\n  constructor(props) {\n    var _this;\n\n    super(props);\n    _this = this;\n    this.clearCache = _asyncToGenerator(function* () {\n      if (!ExpoGoogleSignIn.clearCacheAsync) {\n        return;\n      }\n\n      invariant(_this.auth && _this.auth.accessToken, 'GoogleSignIn: GoogleUser.clearCache(): Invalid accessToken');\n      return yield ExpoGoogleSignIn.clearCacheAsync({\n        token: _this.auth.accessToken\n      });\n    });\n\n    this.getHeaders = () => {\n      invariant(this.auth && this.auth.accessToken && this.auth.accessToken !== '', 'GoogleSignIn: GoogleUser.getHeaders(): Invalid accessToken');\n      return {\n        Authorization: \"Bearer \".concat(this.auth.accessToken),\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      };\n    };\n\n    this.refreshAuth = _asyncToGenerator(function* () {\n      if (!ExpoGoogleSignIn.getTokensAsync) {\n        throw new UnavailabilityError('GoogleSignIn', 'getTokensAsync');\n      }\n\n      var response = yield ExpoGoogleSignIn.getTokensAsync(false);\n\n      if (response.idToken == null) {\n        response.idToken = _this.auth.idToken;\n      }\n\n      if (!_this.auth) {\n        _this.auth = new GoogleAuthentication(response);\n      } else {\n        _this.auth.idToken = response.idToken;\n        _this.auth.accessToken = response.accessToken;\n      }\n\n      return _this.auth;\n    });\n    var {\n      auth,\n      scopes,\n      hostedDomain,\n      serverAuthCode\n    } = props;\n    this.auth = auth;\n    this.scopes = scopes;\n    this.hostedDomain = hostedDomain;\n    this.serverAuthCode = serverAuthCode;\n  }\n\n  equals(other) {\n    if (!super.equals(other) || !(other instanceof GoogleUser)) {\n      return false;\n    }\n\n    return this.auth.equals(other.auth) && this.scopes === other.scopes && this.hostedDomain === other.hostedDomain && this.serverAuthCode === other.serverAuthCode;\n  }\n\n  toJSON() {\n    var auth = this.auth;\n\n    if (this.auth && this.auth.toJSON) {\n      auth = this.auth.toJSON();\n    }\n\n    return _objectSpread(_objectSpread({}, super.toJSON()), {}, {\n      auth,\n      scopes: this.scopes,\n      hostedDomain: this.hostedDomain,\n      serverAuthCode: this.serverAuthCode\n    });\n  }\n\n}\n\nexport default GoogleUser;","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/expo-google-sign-in/src/GoogleUser.js"],"names":["UnavailabilityError","invariant","ExpoGoogleSignIn","GoogleAuthentication","GoogleIdentity","GoogleUser","constructor","props","clearCache","clearCacheAsync","auth","accessToken","token","getHeaders","Authorization","Accept","refreshAuth","getTokensAsync","response","idToken","scopes","hostedDomain","serverAuthCode","equals","other","toJSON"],"mappings":"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","sourcesContent":["// @flow\nimport { UnavailabilityError } from 'expo-errors';\nimport invariant from 'invariant';\n\nimport ExpoGoogleSignIn from './ExpoGoogleSignIn';\nimport GoogleAuthentication from './GoogleAuthentication';\nimport GoogleIdentity from './GoogleIdentity';\n\nclass GoogleUser extends GoogleIdentity {\n  auth: ?GoogleAuthentication;\n  scopes: Array<string>;\n  hostedDomain: ?string;\n  serverAuthCode: ?string;\n\n  constructor(props) {\n    super(props);\n    const { auth, scopes, hostedDomain, serverAuthCode } = props;\n\n    this.auth = auth;\n    this.scopes = scopes;\n    this.hostedDomain = hostedDomain;\n    this.serverAuthCode = serverAuthCode;\n  }\n\n  clearCache = async () => {\n    if (!ExpoGoogleSignIn.clearCacheAsync) {\n      return;\n    }\n    invariant(\n      this.auth && this.auth.accessToken,\n      'GoogleSignIn: GoogleUser.clearCache(): Invalid accessToken'\n    );\n    return await ExpoGoogleSignIn.clearCacheAsync({ token: this.auth.accessToken });\n  };\n\n  getHeaders = (): Promise<{\n    [string]: string,\n  }> => {\n    invariant(\n      this.auth && this.auth.accessToken && this.auth.accessToken !== '',\n      'GoogleSignIn: GoogleUser.getHeaders(): Invalid accessToken'\n    );\n    return {\n      Authorization: `Bearer ${this.auth.accessToken}`,\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    };\n  };\n\n  refreshAuth = async (): Promise<?GoogleAuthentication> => {\n    if (!ExpoGoogleSignIn.getTokensAsync) {\n      throw new UnavailabilityError('GoogleSignIn', 'getTokensAsync');\n    }\n    const response: {\n      idToken: ?string,\n      accessToken: ?string,\n      auth: ?{\n        accessToken: ?string,\n      },\n    } = await ExpoGoogleSignIn.getTokensAsync(false);\n    if (response.idToken == null) {\n      response.idToken = this.auth.idToken;\n    }\n    if (!this.auth) {\n      this.auth = new GoogleAuthentication(response);\n    } else {\n      this.auth.idToken = response.idToken;\n      this.auth.accessToken = response.accessToken;\n    }\n    return this.auth;\n  };\n\n  equals(other: ?any): boolean {\n    if (!super.equals(other) || !(other instanceof GoogleUser)) {\n      return false;\n    }\n\n    return (\n      this.auth.equals(other.auth) &&\n      this.scopes === other.scopes &&\n      this.hostedDomain === other.hostedDomain &&\n      this.serverAuthCode === other.serverAuthCode\n    );\n  }\n\n  toJSON(): { [string]: any } {\n    let auth = this.auth;\n    if (this.auth && this.auth.toJSON) {\n      auth = this.auth.toJSON();\n    }\n\n    return {\n      ...super.toJSON(),\n      auth,\n      scopes: this.scopes,\n      hostedDomain: this.hostedDomain,\n      serverAuthCode: this.serverAuthCode,\n    };\n  }\n}\n\nexport default GoogleUser;\n"]},"metadata":{},"sourceType":"module"}