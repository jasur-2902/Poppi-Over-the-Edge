{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport AsyncStorage from \"react-native-web/dist/exports/AsyncStorage\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport DeviceEventEmitter from 'react-native/Libraries/EventEmitter/RCTDeviceEventEmitter';\nimport ExponentNotifications from \"./ExponentNotifications\";\n\nvar _emitter;\n\nvar _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    DeviceEventEmitter.addListener('Exponent.notification', _emitNotification);\n  }\n}\n\nfunction _emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  notification = _objectSpread({}, notification);\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {}\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = _extends({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = _extends(notification, notification.ios);\n      delete notification.ios;\n    }\n  }\n\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = _extends(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(!!notification.title && !!notification.body, 'Local notifications on iOS require both a title and a body');\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nvar ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\nvar IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\n\nfunction _legacyReadChannel(_x) {\n  return _legacyReadChannel2.apply(this, arguments);\n}\n\nfunction _legacyReadChannel2() {\n  _legacyReadChannel2 = _asyncToGenerator(function* (id) {\n    try {\n      var channelString = yield AsyncStorage.getItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n\n      if (channelString) {\n        return JSON.parse(channelString);\n      }\n    } catch (e) {}\n\n    return null;\n  });\n  return _legacyReadChannel2.apply(this, arguments);\n}\n\nfunction _legacyDeleteChannel(id) {\n  return AsyncStorage.removeItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = function () {\n    var _ref = _asyncToGenerator(function* (callback) {\n      try {\n        var keys = yield AsyncStorage.getAllKeys();\n        var result = null;\n\n        if (keys && keys.length) {\n          var filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n          yield AsyncStorage.multiRemove(filteredKeys);\n        }\n\n        callback && callback();\n      } catch (e) {\n        callback && callback(e);\n        throw e;\n      }\n    });\n\n    return function (_x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction _legacySaveChannel(id, channel) {\n  return AsyncStorage.setItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id), JSON.stringify(channel));\n}\n\nexport default {\n  _setInitialNotification(notification) {\n    _initialNotification = notification;\n  },\n\n  createCategoryAsync(categoryId, actions) {\n    return ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n\n  deleteCategoryAsync(categoryId) {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n\n  getExpoPushTokenAsync() {\n    if (!Constants.isDevice) {\n      throw new Error(\"Must be on a physical device to get an Expo Push Token\");\n    }\n\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  getDevicePushTokenAsync: config => ExponentNotifications.getDevicePushTokenAsync(config || {}),\n\n  createChannelAndroidAsync(id, channel) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"createChannelAndroidAsync(...) has no effect on \".concat(Platform.OS));\n      return Promise.resolve();\n    }\n\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id) {\n    if (Platform.OS === 'ios') {\n      console.warn('deleteChannelAndroidAsync(...) has no effect on iOS');\n      return Promise.resolve();\n    }\n\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  presentLocalNotificationAsync(notification) {\n    return _asyncToGenerator(function* () {\n      _validateNotification(notification);\n\n      var nativeNotification = _processNotification(notification);\n\n      if (Platform.OS === 'ios') {\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      } else {\n        var _channel;\n\n        if (nativeNotification.channelId) {\n          _channel = yield _legacyReadChannel(nativeNotification.channelId);\n        }\n\n        if (IS_USING_NEW_BINARY) {\n          _legacyDeleteChannel(nativeNotification.channelId);\n\n          return ExponentNotifications.presentLocalNotificationWithChannel(nativeNotification, _channel);\n        } else {\n          if (_channel) {\n            nativeNotification.sound = _channel.sound;\n            nativeNotification.priority = _channel.priority;\n            nativeNotification.vibrate = _channel.vibrate;\n          }\n\n          return ExponentNotifications.presentLocalNotification(nativeNotification);\n        }\n      }\n    })();\n  },\n\n  scheduleLocalNotificationAsync(notification) {\n    var _arguments = arguments;\n    return _asyncToGenerator(function* () {\n      var options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};\n      var now = Date.now();\n\n      _validateNotification(notification);\n\n      var nativeNotification = _processNotification(notification);\n\n      if (options.time) {\n        var timeAsDateObj = null;\n\n        if (options.time && typeof options.time === 'number') {\n          timeAsDateObj = new Date(options.time);\n\n          if (timeAsDateObj.toString() === 'Invalid Date') {\n            timeAsDateObj = null;\n          }\n        } else if (options.time && options.time instanceof Date) {\n          timeAsDateObj = options.time;\n        }\n\n        if (!timeAsDateObj) {\n          throw new Error(\"Provided value for \\\"time\\\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.\");\n        }\n\n        if (timeAsDateObj.getTime() < now) {\n          console.warn(\"Provided value for \\\"time\\\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?\");\n        }\n\n        options = _objectSpread({}, options, {\n          time: timeAsDateObj.getTime()\n        });\n      }\n\n      if (options.intervalMs != null && options.repeat != null) {\n        throw new Error(\"Pass either the \\\"repeat\\\" option or \\\"intervalMs\\\" option, not both\");\n      }\n\n      if (options.repeat != null) {\n        var validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n\n        if (!validOptions.has(options.repeat)) {\n          throw new Error(\"Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \\\"repeat\\\" option\");\n        }\n      }\n\n      if (options.intervalMs != null) {\n        if (Platform.OS === 'ios') {\n          throw new Error(\"The \\\"intervalMs\\\" option is not supported on iOS\");\n        }\n\n        if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n          throw new Error(\"Pass an integer greater than zero as the value for the \\\"intervalMs\\\" option\");\n        }\n      }\n\n      if (Platform.OS === 'ios') {\n        if (options.repeat) {\n          console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n          return ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options);\n        }\n\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      } else {\n        var _channel;\n\n        if (nativeNotification.channelId) {\n          _channel = yield _legacyReadChannel(nativeNotification.channelId);\n        }\n\n        if (IS_USING_NEW_BINARY) {\n          _legacyDeleteChannel(nativeNotification.channelId);\n\n          return ExponentNotifications.scheduleLocalNotificationWithChannel(nativeNotification, options, _channel);\n        } else {\n          if (_channel) {\n            nativeNotification.sound = _channel.sound;\n            nativeNotification.priority = _channel.priority;\n            nativeNotification.vibrate = _channel.vibrate;\n          }\n\n          return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n        }\n      }\n    })();\n  },\n\n  dismissNotificationAsync(notificationId) {\n    return _asyncToGenerator(function* () {\n      if (Platform.OS === 'android') {\n        return ExponentNotifications.dismissNotification(notificationId);\n      } else {\n        throw new Error('Dismissing notifications is not supported on iOS');\n      }\n    })();\n  },\n\n  dismissAllNotificationsAsync() {\n    return _asyncToGenerator(function* () {\n      if (Platform.OS === 'android') {\n        return ExponentNotifications.dismissAllNotifications();\n      } else {\n        throw new Error('Dismissing notifications is not supported on iOS');\n      }\n    })();\n  },\n\n  cancelScheduledNotificationAsync(notificationId) {\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n\n  cancelAllScheduledNotificationsAsync() {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n\n  addListener(listener) {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      var initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        _emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  getBadgeNumberAsync() {\n    return _asyncToGenerator(function* () {\n      if (!ExponentNotifications.getBadgeNumberAsync) {\n        return 0;\n      }\n\n      return ExponentNotifications.getBadgeNumberAsync();\n    })();\n  },\n\n  setBadgeNumberAsync(number) {\n    return _asyncToGenerator(function* () {\n      if (!ExponentNotifications.setBadgeNumberAsync) {\n        return;\n      }\n\n      return ExponentNotifications.setBadgeNumberAsync(number);\n    })();\n  }\n\n};","map":{"version":3,"sources":["../../src/Notifications/Notifications.ts"],"names":[],"mappings":"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","sourcesContent":["import Constants from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport { AsyncStorage, Platform } from 'react-native';\nimport DeviceEventEmitter from 'react-native/Libraries/EventEmitter/RCTDeviceEventEmitter';\nimport ExponentNotifications from './ExponentNotifications';\n\ntype Notification = {\n  origin: 'selected' | 'received';\n  data: any;\n  remote: boolean;\n  isMultiple: boolean;\n};\n\ntype LocalNotification = {\n  title: string;\n  // How should we deal with body being required on iOS but not on Android?\n  body?: string;\n  data?: any;\n  categoryId?: string;\n  ios?: {\n    sound?: boolean;\n  };\n  android?: {\n    channelId?: string;\n    icon?: string;\n    color?: string;\n    sticky?: boolean;\n    link?: string;\n  };\n};\n\ntype Channel = {\n  name: string;\n  description?: string;\n  priority?: string;\n  sound?: boolean;\n  vibrate?: boolean | number[];\n  badge?: boolean;\n};\n\ntype ActionType = {\n  actionId: string;\n  buttonTitle: string;\n  isDestructive?: boolean;\n  isAuthenticationRequired?: boolean;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n};\n\n// Android assigns unique number to each notification natively.\n// Since that's not supported on iOS, we generate an unique string.\ntype LocalNotificationId = string | number;\n\nlet _emitter;\nlet _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    DeviceEventEmitter.addListener('Exponent.notification', _emitNotification);\n  }\n}\n\nfunction _emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  /* Don't mutate the original notification */\n  notification = { ...notification };\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {\n      // It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  // Delete any Android properties on iOS and merge the iOS properties on root notification object\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      delete notification.ios;\n    }\n  }\n\n  // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(\n      !!notification.title && !!notification.body,\n      'Local notifications on iOS require both a title and a body'\n    );\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nlet ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\n// TODO: remove this before releasing\n// this will always be `true` for SDK 28+\nlet IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\n\nasync function _legacyReadChannel(id: string): Promise<Channel | null> {\n  try {\n    let channelString = await AsyncStorage.getItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n    if (channelString) {\n      return JSON.parse(channelString);\n    }\n  } catch (e) {}\n  return null;\n}\n\nfunction _legacyDeleteChannel(id: string): Promise<void> {\n  return AsyncStorage.removeItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = async function(callback?: (error?: Error) => void): Promise<void> {\n    try {\n      let keys = await AsyncStorage.getAllKeys();\n      let result = null;\n      if (keys && keys.length) {\n        let filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n        await AsyncStorage.multiRemove(filteredKeys);\n      }\n      callback && callback();\n    } catch (e) {\n      callback && callback(e);\n      throw e;\n    }\n  };\n}\n\n// This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\nfunction _legacySaveChannel(id: string, channel: Channel): Promise<void> {\n  return AsyncStorage.setItem(`${ASYNC_STORAGE_PREFIX}${id}`, JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification(notification: Notification) {\n    _initialNotification = notification;\n  },\n\n  // User passes set of actions titles.\n  createCategoryAsync(categoryId: string, actions: ActionType[]): Promise<void> {\n    return ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n\n  deleteCategoryAsync(categoryId: string): Promise<void> {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync(): Promise<string> {\n    if (!Constants.isDevice) {\n      throw new Error(`Must be on a physical device to get an Expo Push Token`);\n    }\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  getDevicePushTokenAsync: (config: {\n    gcmSenderId?: string;\n  }): Promise<{ type: string; data: string }> =>\n    ExponentNotifications.getDevicePushTokenAsync(config || {}),\n\n  createChannelAndroidAsync(id: string, channel: Channel): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`createChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id: string): Promise<void> {\n    if (Platform.OS === 'ios') {\n      console.warn('deleteChannelAndroidAsync(...) has no effect on iOS');\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  async presentLocalNotificationAsync(\n    notification: LocalNotification\n  ): Promise<LocalNotificationId> {\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    if (Platform.OS === 'ios') {\n      return ExponentNotifications.presentLocalNotification(nativeNotification);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.presentLocalNotificationWithChannel(\n          nativeNotification,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      }\n    }\n  },\n\n  /* Schedule a notification at a later date */\n  async scheduleLocalNotificationAsync(\n    notification: LocalNotification,\n    options: {\n      time?: Date | number;\n      repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n      intervalMs?: number;\n    } = {}\n  ): Promise<LocalNotificationId> {\n    // set now at the beginning of the method, to prevent potential weird warnings when we validate\n    // options.time later on\n    const now = Date.now();\n\n    // Validate and process the notification data\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    // Validate `options.time`\n    if (options.time) {\n      let timeAsDateObj: Date | null = null;\n      if (options.time && typeof options.time === 'number') {\n        timeAsDateObj = new Date(options.time);\n        if (timeAsDateObj.toString() === 'Invalid Date') {\n          timeAsDateObj = null;\n        }\n      } else if (options.time && options.time instanceof Date) {\n        timeAsDateObj = options.time;\n      }\n\n      // If we couldn't convert properly, throw an error\n      if (!timeAsDateObj) {\n        throw new Error(\n          `Provided value for \"time\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.`\n        );\n      }\n\n      // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n      // accidently pass seconds instead of ms), display a warning.\n      if (timeAsDateObj.getTime() < now) {\n        console.warn(\n          `Provided value for \"time\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?`\n        );\n      }\n\n      options = {\n        ...options,\n        time: timeAsDateObj.getTime(),\n      };\n    }\n\n    if (options.intervalMs != null && options.repeat != null) {\n      throw new Error(`Pass either the \"repeat\" option or \"intervalMs\" option, not both`);\n    }\n\n    // Validate options.repeat\n    if (options.repeat != null) {\n      const validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n      if (!validOptions.has(options.repeat)) {\n        throw new Error(\n          `Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \"repeat\" option`\n        );\n      }\n    }\n\n    if (options.intervalMs != null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(`The \"intervalMs\" option is not supported on iOS`);\n      }\n\n      if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n        throw new Error(\n          `Pass an integer greater than zero as the value for the \"intervalMs\" option`\n        );\n      }\n    }\n\n    if (Platform.OS === 'ios') {\n      if (options.repeat) {\n        console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n        return ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options);\n      }\n\n      return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.scheduleLocalNotificationWithChannel(\n          nativeNotification,\n          options,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      }\n    }\n  },\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  async dismissNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (Platform.OS === 'android') {\n      return ExponentNotifications.dismissNotification(notificationId);\n    } else {\n      throw new Error('Dismissing notifications is not supported on iOS');\n    }\n  },\n\n  /* Dismiss all currently shown notifications (Android only) */\n  async dismissAllNotificationsAsync(): Promise<void> {\n    if (Platform.OS === 'android') {\n      return ExponentNotifications.dismissAllNotifications();\n    } else {\n      throw new Error('Dismissing notifications is not supported on iOS');\n    }\n  },\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync(): Promise<void> {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n\n  /* Primary public api */\n  addListener(listener: Function): EventSubscription {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      const initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        _emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  async getBadgeNumberAsync(): Promise<number> {\n    if (!ExponentNotifications.getBadgeNumberAsync) {\n      return 0;\n    }\n    return ExponentNotifications.getBadgeNumberAsync();\n  },\n\n  async setBadgeNumberAsync(number: number): Promise<void> {\n    if (!ExponentNotifications.setBadgeNumberAsync) {\n      return;\n    }\n    return ExponentNotifications.setBadgeNumberAsync(number);\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}