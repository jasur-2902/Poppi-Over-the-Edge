{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { UnavailabilityError } from '@unimodules/core';\nimport ExpoImageManipulator from \"./ExpoImageManipulator\";\nimport { SaveFormat } from \"./ImageManipulator.types\";\nexport function manipulateAsync(_x) {\n  return _manipulateAsync.apply(this, arguments);\n}\n\nfunction _manipulateAsync() {\n  _manipulateAsync = _asyncToGenerator(function* (uri) {\n    var actions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        {\n      format = SaveFormat.JPEG\n    } = _ref,\n        rest = _objectWithoutProperties(_ref, [\"format\"]);\n\n    if (!ExpoImageManipulator.manipulateAsync) {\n      throw new UnavailabilityError('ImageManipulator', 'manipulateAsync');\n    }\n\n    if (!(typeof uri === 'string')) {\n      throw new TypeError('The \"uri\" argument must be a string');\n    }\n\n    return yield ExpoImageManipulator.manipulateAsync(uri, actions, _objectSpread({\n      format\n    }, rest));\n  });\n  return _manipulateAsync.apply(this, arguments);\n}\n\nexport * from \"./ImageManipulator.types\";","map":{"version":3,"sources":["../src/ImageManipulator.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,SAAS,mBAAT,QAAoC,kBAApC;AAEA,OAAO,oBAAP;AACA,SAA8B,UAA9B;AAEA,gBAAsB,eAAtB;AAAA;AAAA;;;uCAAO,WACL,GADK,EAGkD;AAAA,QADvD,OACuD,uEADnC,EACmC;;AAAA,mFAAF,EAAE;AAAA,QAAvD;AAAE,MAAA,MAAM,GAAG,UAAU,CAAC;AAAtB,KAAuD;AAAA,QAAxB,IAAwB;;AAEvD,QAAI,CAAC,oBAAoB,CAAC,eAA1B,EAA2C;AACzC,YAAM,IAAI,mBAAJ,CAAwB,kBAAxB,EAA4C,iBAA5C,CAAN;AACD;;AACD,QAAI,EAAE,OAAO,GAAP,KAAe,QAAjB,CAAJ,EAAgC;AAC9B,YAAM,IAAI,SAAJ,CAAc,qCAAd,CAAN;AACD;;AACD,iBAAa,oBAAoB,CAAC,eAArB,CAAqC,GAArC,EAA0C,OAA1C;AAAqD,MAAA;AAArD,OAAgE,IAAhE,EAAb;AACD,G;;;;AAED","sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\n\nimport ExpoImageManipulator from './ExpoImageManipulator';\nimport { Action, ImageResult, SaveFormat, SaveOptions } from './ImageManipulator.types';\n\nexport async function manipulateAsync(\n  uri: string,\n  actions: Action[] = [],\n  { format = SaveFormat.JPEG, ...rest }: SaveOptions = {}\n): Promise<ImageResult> {\n  if (!ExpoImageManipulator.manipulateAsync) {\n    throw new UnavailabilityError('ImageManipulator', 'manipulateAsync');\n  }\n  if (!(typeof uri === 'string')) {\n    throw new TypeError('The \"uri\" argument must be a string');\n  }\n  return await ExpoImageManipulator.manipulateAsync(uri, actions, { format, ...rest });\n}\n\nexport * from './ImageManipulator.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}