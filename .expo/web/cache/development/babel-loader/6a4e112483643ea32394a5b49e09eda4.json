{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport '@expo/browser-polyfill';\nimport * as filters from 'pixi-filters';\nimport * as PixiInstance from 'pixi.js';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { resolveAsync } from 'expo-asset-utils';\nglobal.PIXI = global.PIXI || PixiInstance;\nvar PIXI = global.PIXI;\nPIXI.filters = _objectSpread({}, PIXI.filters || {}, {}, filters);\n\nclass ExpoPIXIApplication extends PIXI.Application {\n  constructor(_ref) {\n    var {\n      width,\n      height,\n      scale,\n      backgroundColor,\n      context\n    } = _ref,\n        props = _objectWithoutProperties(_ref, [\"width\", \"height\", \"scale\", \"backgroundColor\", \"context\"]);\n\n    if (!context) throw new Error('expo-pixi: new Application({ context: null }): context must be a valid WebGL context.');\n\n    if (Platform.OS !== 'web') {\n      var getAttributes = context.getContextAttributes || (() => ({}));\n\n      context.getContextAttributes = () => {\n        var contextAttributes = getAttributes();\n        return _objectSpread({}, contextAttributes, {\n          stencil: true\n        });\n      };\n    }\n\n    var resolution = scale || 1;\n    super(_objectSpread({\n      context,\n      resolution,\n      width: width || context.drawingBufferWidth / resolution,\n      height: height || context.drawingBufferHeight / resolution,\n      backgroundColor\n    }, props));\n    this.ticker.add(() => context.endFrameEXP());\n  }\n\n}\n\nvar isAsset = input => {\n  return input && typeof input.width === 'number' && typeof input.height === 'number' && typeof input.localUri === 'string';\n};\n\nif (!(PIXI.Application instanceof ExpoPIXIApplication)) {\n  var {\n    HTMLImageElement\n  } = global;\n\n  var textureFromExpoAsync = function () {\n    var _ref2 = _asyncToGenerator(function* (resource) {\n      var asset = resource;\n\n      if (Platform.OS !== 'web') {\n        asset = yield resolveAsync(resource);\n      }\n\n      return PIXI.Texture.from(asset);\n    });\n\n    return function textureFromExpoAsync(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var spriteFromExpoAsync = function () {\n    var _ref3 = _asyncToGenerator(function* (resource) {\n      var texture = yield textureFromExpoAsync(resource);\n      return PIXI.Sprite.from(texture);\n    });\n\n    return function spriteFromExpoAsync(_x2) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  var originalSpriteFrom = PIXI.Sprite.from;\n  var originalTextureFrom = PIXI.Texture.from;\n  PIXI = _objectSpread({}, PIXI, {\n    Application: ExpoPIXIApplication,\n    Texture: _objectSpread({}, PIXI.Texture, {\n      from: function from() {\n        if (Platform.OS === 'web') {\n          return originalTextureFrom(...arguments);\n        }\n\n        if (arguments.length && (arguments.length <= 0 ? undefined : arguments[0])) {\n          var asset = arguments.length <= 0 ? undefined : arguments[0];\n\n          if (isAsset(asset)) {\n            if (asset instanceof HTMLImageElement) {\n              return originalTextureFrom(asset);\n            } else {\n              return originalTextureFrom(new HTMLImageElement(asset));\n            }\n          } else if (typeof asset === 'string' || typeof asset === 'number') {\n            console.warn(\"PIXI.Texture.from(asset: \".concat(typeof asset, \") is not supported. Returning a Promise!\"));\n            return textureFromExpoAsync(asset);\n          }\n        }\n\n        return originalTextureFrom(...arguments);\n      },\n      fromExpoAsync: textureFromExpoAsync\n    }),\n    Sprite: _objectSpread({}, PIXI.Sprite, {\n      fromExpoAsync: spriteFromExpoAsync,\n      from: function from() {\n        if (Platform.OS === 'web') {\n          return originalSpriteFrom(...arguments);\n        }\n\n        if (arguments.length && (arguments.length <= 0 ? undefined : arguments[0])) {\n          var asset = arguments.length <= 0 ? undefined : arguments[0];\n\n          if (isAsset(asset)) {\n            var image = new HTMLImageElement(asset);\n            return originalSpriteFrom(image);\n          } else if (typeof asset === 'string' || typeof asset === 'number') {\n            console.warn(\"PIXI.Sprite.from(asset: \".concat(typeof asset, \") is not supported. Returning a Promise!\"));\n            return spriteFromExpoAsync(asset);\n          }\n        }\n\n        return originalSpriteFrom(...arguments);\n      }\n    })\n  });\n}\n\nexport default PIXI;","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/expo-pixi/lib/Pixi.js"],"names":["filters","PixiInstance","resolveAsync","global","PIXI","ExpoPIXIApplication","Application","constructor","width","height","scale","backgroundColor","context","props","Error","Platform","OS","getAttributes","getContextAttributes","contextAttributes","stencil","resolution","drawingBufferWidth","drawingBufferHeight","ticker","add","endFrameEXP","isAsset","input","localUri","HTMLImageElement","textureFromExpoAsync","resource","asset","Texture","from","spriteFromExpoAsync","texture","Sprite","originalSpriteFrom","originalTextureFrom","length","console","warn","fromExpoAsync","image"],"mappings":";;;;;;;;;;;;;;AAAA,OAAO,wBAAP;AAEA,OAAO,KAAKA,OAAZ,MAAyB,cAAzB;AACA,OAAO,KAAKC,YAAZ,MAA8B,SAA9B;;AAEA,SAASC,YAAT,QAA6B,kBAA7B;AAEAC,MAAM,CAACC,IAAP,GAAcD,MAAM,CAACC,IAAP,IAAeH,YAA7B;AACA,IAAIG,IAAI,GAAGD,MAAM,CAACC,IAAlB;AACAA,IAAI,CAACJ,OAAL,qBAAqBI,IAAI,CAACJ,OAAL,IAAgB,EAArC,MAA6CA,OAA7C;;AAEA,MAAMK,mBAAN,SAAkCD,IAAI,CAACE,WAAvC,CAAmD;AACjDC,EAAAA,WAAW,OAA+D;AAAA,QAA9D;AAAEC,MAAAA,KAAF;AAASC,MAAAA,MAAT;AAAiBC,MAAAA,KAAjB;AAAwBC,MAAAA,eAAxB;AAAyCC,MAAAA;AAAzC,KAA8D;AAAA,QAATC,KAAS;;AACxE,QAAI,CAACD,OAAL,EACE,MAAM,IAAIE,KAAJ,CACJ,uFADI,CAAN;;AAIF,QAAIC,QAAQ,CAACC,EAAT,KAAgB,KAApB,EAA2B;AAEzB,UAAMC,aAAa,GAAGL,OAAO,CAACM,oBAAR,KAAiC,OAAO,EAAP,CAAjC,CAAtB;;AACAN,MAAAA,OAAO,CAACM,oBAAR,GAA+B,MAAM;AACnC,YAAMC,iBAAiB,GAAGF,aAAa,EAAvC;AACA,iCACKE,iBADL;AAEEC,UAAAA,OAAO,EAAE;AAFX;AAID,OAND;AAOD;;AAED,QAAMC,UAAU,GAAGX,KAAK,IAAI,CAA5B;AACA;AACEE,MAAAA,OADF;AAEES,MAAAA,UAFF;AAGEb,MAAAA,KAAK,EAAEA,KAAK,IAAII,OAAO,CAACU,kBAAR,GAA6BD,UAH/C;AAIEZ,MAAAA,MAAM,EAAEA,MAAM,IAAIG,OAAO,CAACW,mBAAR,GAA8BF,UAJlD;AAKEV,MAAAA;AALF,OAMKE,KANL;AAQA,SAAKW,MAAL,CAAYC,GAAZ,CAAgB,MAAMb,OAAO,CAACc,WAAR,EAAtB;AACD;;AA7BgD;;AAgCnD,IAAMC,OAAO,GAAGC,KAAK,IAAI;AACvB,SACEA,KAAK,IACL,OAAOA,KAAK,CAACpB,KAAb,KAAuB,QADvB,IAEA,OAAOoB,KAAK,CAACnB,MAAb,KAAwB,QAFxB,IAGA,OAAOmB,KAAK,CAACC,QAAb,KAA0B,QAJ5B;AAMD,CAPD;;AASA,IAAI,EAAEzB,IAAI,CAACE,WAAL,YAA4BD,mBAA9B,CAAJ,EAAwD;AACtD,MAAM;AAAEyB,IAAAA;AAAF,MAAuB3B,MAA7B;;AAEA,MAAM4B,oBAAoB;AAAA,kCAAG,WAAMC,QAAN,EAAkB;AAC7C,UAAIC,KAAK,GAAGD,QAAZ;;AACA,UAAIjB,QAAQ,CAACC,EAAT,KAAgB,KAApB,EAA2B;AACzBiB,QAAAA,KAAK,SAAS/B,YAAY,CAAC8B,QAAD,CAA1B;AACD;;AACD,aAAO5B,IAAI,CAAC8B,OAAL,CAAaC,IAAb,CAAkBF,KAAlB,CAAP;AACD,KANyB;;AAAA,oBAApBF,oBAAoB;AAAA;AAAA;AAAA,KAA1B;;AAQA,MAAMK,mBAAmB;AAAA,kCAAG,WAAMJ,QAAN,EAAkB;AAC5C,UAAMK,OAAO,SAASN,oBAAoB,CAACC,QAAD,CAA1C;AACA,aAAO5B,IAAI,CAACkC,MAAL,CAAYH,IAAZ,CAAiBE,OAAjB,CAAP;AACD,KAHwB;;AAAA,oBAAnBD,mBAAmB;AAAA;AAAA;AAAA,KAAzB;;AAKA,MAAMG,kBAAkB,GAAGnC,IAAI,CAACkC,MAAL,CAAYH,IAAvC;AACA,MAAMK,mBAAmB,GAAGpC,IAAI,CAAC8B,OAAL,CAAaC,IAAzC;AACA/B,EAAAA,IAAI,qBACCA,IADD;AAEFE,IAAAA,WAAW,EAAED,mBAFX;AAGF6B,IAAAA,OAAO,oBACF9B,IAAI,CAAC8B,OADH;AAELC,MAAAA,IAAI,EAAE,gBAAc;AAClB,YAAIpB,QAAQ,CAACC,EAAT,KAAgB,KAApB,EAA2B;AACzB,iBAAOwB,mBAAmB,CAAC,YAAD,CAA1B;AACD;;AACD,YAAI,UAAMC,MAAN,sDAAJ,EAA8B;AAC5B,cAAIR,KAAK,mDAAT;;AACA,cAAIN,OAAO,CAACM,KAAD,CAAX,EAAoB;AAClB,gBAAIA,KAAK,YAAYH,gBAArB,EAAuC;AACrC,qBAAOU,mBAAmB,CAACP,KAAD,CAA1B;AACD,aAFD,MAEO;AACL,qBAAOO,mBAAmB,CAAC,IAAIV,gBAAJ,CAAqBG,KAArB,CAAD,CAA1B;AACD;AACF,WAND,MAMO,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,QAAlD,EAA4D;AACjES,YAAAA,OAAO,CAACC,IAAR,oCAC8B,OAAOV,KADrC;AAGA,mBAAOF,oBAAoB,CAACE,KAAD,CAA3B;AACD;AACF;;AACD,eAAOO,mBAAmB,CAAC,YAAD,CAA1B;AACD,OAtBI;AAuBLI,MAAAA,aAAa,EAAEb;AAvBV,MAHL;AA4BFO,IAAAA,MAAM,oBACDlC,IAAI,CAACkC,MADJ;AAEJM,MAAAA,aAAa,EAAER,mBAFX;AAGJD,MAAAA,IAAI,EAAE,gBAAc;AAClB,YAAIpB,QAAQ,CAACC,EAAT,KAAgB,KAApB,EAA2B;AACzB,iBAAOuB,kBAAkB,CAAC,YAAD,CAAzB;AACD;;AACD,YAAI,UAAME,MAAN,sDAAJ,EAA8B;AAC5B,cAAIR,KAAK,mDAAT;;AACA,cAAIN,OAAO,CAACM,KAAD,CAAX,EAAoB;AAClB,gBAAMY,KAAK,GAAG,IAAIf,gBAAJ,CAAqBG,KAArB,CAAd;AACA,mBAAOM,kBAAkB,CAACM,KAAD,CAAzB;AACD,WAHD,MAGO,IAAI,OAAOZ,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,QAAlD,EAA4D;AACjES,YAAAA,OAAO,CAACC,IAAR,mCAC6B,OAAOV,KADpC;AAGA,mBAAOG,mBAAmB,CAACH,KAAD,CAA1B;AACD;AACF;;AAED,eAAOM,kBAAkB,CAAC,YAAD,CAAzB;AACD;AArBG;AA5BJ,IAAJ;AAoDD;;AAED,eAAenC,IAAf","sourcesContent":["import '@expo/browser-polyfill';\n\nimport * as filters from 'pixi-filters';\nimport * as PixiInstance from 'pixi.js';\nimport { Platform } from 'react-native';\nimport { resolveAsync } from 'expo-asset-utils';\n\nglobal.PIXI = global.PIXI || PixiInstance;\nlet PIXI = global.PIXI;\nPIXI.filters = { ...(PIXI.filters || {}), ...filters };\n\nclass ExpoPIXIApplication extends PIXI.Application {\n  constructor({ width, height, scale, backgroundColor, context, ...props }) {\n    if (!context)\n      throw new Error(\n        'expo-pixi: new Application({ context: null }): context must be a valid WebGL context.'\n      );\n\n    if (Platform.OS !== 'web') {\n      // Shim stencil buffer attribute\n      const getAttributes = context.getContextAttributes || (() => ({}));\n      context.getContextAttributes = () => {\n        const contextAttributes = getAttributes();\n        return {\n          ...contextAttributes,\n          stencil: true,\n        };\n      };\n    }\n\n    const resolution = scale || 1; //PixelRatio.get();\n    super({\n      context,\n      resolution,\n      width: width || context.drawingBufferWidth / resolution,\n      height: height || context.drawingBufferHeight / resolution,\n      backgroundColor,\n      ...props,\n    });\n    this.ticker.add(() => context.endFrameEXP());\n  }\n}\n\nconst isAsset = input => {\n  return (\n    input &&\n    typeof input.width === 'number' &&\n    typeof input.height === 'number' &&\n    typeof input.localUri === 'string'\n  );\n};\n\nif (!(PIXI.Application instanceof ExpoPIXIApplication)) {\n  const { HTMLImageElement } = global;\n\n  const textureFromExpoAsync = async resource => {\n    let asset = resource;\n    if (Platform.OS !== 'web') {\n      asset = await resolveAsync(resource);\n    }\n    return PIXI.Texture.from(asset);\n  };\n\n  const spriteFromExpoAsync = async resource => {\n    const texture = await textureFromExpoAsync(resource);\n    return PIXI.Sprite.from(texture);\n  };\n\n  const originalSpriteFrom = PIXI.Sprite.from;\n  const originalTextureFrom = PIXI.Texture.from;\n  PIXI = {\n    ...PIXI,\n    Application: ExpoPIXIApplication,\n    Texture: {\n      ...PIXI.Texture,\n      from: (...props) => {\n        if (Platform.OS === 'web') {\n          return originalTextureFrom(...props);\n        }\n        if (props.length && props[0]) {\n          let asset = props[0];\n          if (isAsset(asset)) {\n            if (asset instanceof HTMLImageElement) {\n              return originalTextureFrom(asset);\n            } else {\n              return originalTextureFrom(new HTMLImageElement(asset));\n            }\n          } else if (typeof asset === 'string' || typeof asset === 'number') {\n            console.warn(\n              `PIXI.Texture.from(asset: ${typeof asset}) is not supported. Returning a Promise!`\n            );\n            return textureFromExpoAsync(asset);\n          }\n        }\n        return originalTextureFrom(...props);\n      },\n      fromExpoAsync: textureFromExpoAsync,\n    },\n    Sprite: {\n      ...PIXI.Sprite,\n      fromExpoAsync: spriteFromExpoAsync,\n      from: (...props) => {\n        if (Platform.OS === 'web') {\n          return originalSpriteFrom(...props);\n        }\n        if (props.length && props[0]) {\n          let asset = props[0];\n          if (isAsset(asset)) {\n            const image = new HTMLImageElement(asset);\n            return originalSpriteFrom(image);\n          } else if (typeof asset === 'string' || typeof asset === 'number') {\n            console.warn(\n              `PIXI.Sprite.from(asset: ${typeof asset}) is not supported. Returning a Promise!`\n            );\n            return spriteFromExpoAsync(asset);\n          }\n        }\n\n        return originalSpriteFrom(...props);\n      },\n    },\n  };\n}\n\nexport default PIXI;\n"]},"metadata":{},"sourceType":"module"}