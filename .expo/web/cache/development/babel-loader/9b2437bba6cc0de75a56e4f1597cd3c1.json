{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nexport default {\n  get name() {\n    return 'ExponentSpeech';\n  },\n\n  speak(id, text, options) {\n    return _asyncToGenerator(function* () {\n      var {\n        SpeechSynthesisUtterance\n      } = global.window;\n      var message = new SpeechSynthesisUtterance();\n\n      if ('rate' in options) {\n        message.rate = options.rate;\n      }\n\n      if ('pitch' in options) {\n        message.pitch = options.pitch;\n      }\n\n      if ('language' in options) {\n        message.lang = options.language;\n      }\n\n      if ('volume' in options) {\n        message.volume = options.volume;\n      }\n\n      if ('_voiceIndex' in options && options._voiceIndex != null) {\n        var voices = window.speechSynthesis.getVoices();\n        message.voice = voices[Math.min(voices.length - 1, Math.max(0, options._voiceIndex))];\n      }\n\n      if ('onStart' in options) {\n        message.onstart = options.onStart;\n      }\n\n      if ('onDone' in options) {\n        message.onend = options.onDone;\n      }\n\n      if ('onError' in options) {\n        message.onerror = options.onError;\n      }\n\n      if ('onPause' in options) {\n        message.onpause = options.onPause;\n      }\n\n      if ('onResume' in options) {\n        message.onresume = options.onResume;\n      }\n\n      if ('onMark' in options) {\n        message.onmark = options.onMark;\n      }\n\n      if ('onBoundary' in options) {\n        message.onboundary = options.onBoundary;\n      }\n\n      message.text = text;\n      window.speechSynthesis.speak(message);\n      return message;\n    })();\n  },\n\n  isSpeaking() {\n    return _asyncToGenerator(function* () {\n      return window.speechSynthesis.speaking;\n    })();\n  },\n\n  stop() {\n    return _asyncToGenerator(function* () {\n      return window.speechSynthesis.cancel();\n    })();\n  },\n\n  pause() {\n    return _asyncToGenerator(function* () {\n      return window.speechSynthesis.pause();\n    })();\n  },\n\n  resume() {\n    return _asyncToGenerator(function* () {\n      return window.speechSynthesis.resume();\n    })();\n  }\n\n};","map":{"version":3,"sources":["../src/Speech/ExponentSpeech.web.ts"],"names":[],"mappings":";;;;AAEA,eAAe;AACb,MAAI,IAAJ,GAAQ;AACN,WAAO,gBAAP;AACD,GAHY;;AAIP,EAAA,KAAN,CAAY,EAAZ,EAAwB,IAAxB,EAAsC,OAAtC,EAA4D;AAAA;AAE1D,UAAM;AAAE,QAAA;AAAF,UAA+B,MAAM,CAAC,MAA5C;AAEA,UAAM,OAAO,GAAG,IAAI,wBAAJ,EAAhB;;AAEA,UAAI,UAAU,OAAd,EAAuB;AACrB,QAAA,OAAO,CAAC,IAAR,GAAe,OAAO,CAAC,IAAvB;AACD;;AACD,UAAI,WAAW,OAAf,EAAwB;AACtB,QAAA,OAAO,CAAC,KAAR,GAAgB,OAAO,CAAC,KAAxB;AACD;;AACD,UAAI,cAAc,OAAlB,EAA2B;AACzB,QAAA,OAAO,CAAC,IAAR,GAAe,OAAO,CAAC,QAAvB;AACD;;AACD,UAAI,YAAY,OAAhB,EAAyB;AACvB,QAAA,OAAO,CAAC,MAAR,GAAiB,OAAO,CAAC,MAAzB;AACD;;AACD,UAAI,iBAAiB,OAAjB,IAA4B,OAAO,CAAC,WAAR,IAAuB,IAAvD,EAA6D;AAC3D,YAAM,MAAM,GAAG,MAAM,CAAC,eAAP,CAAuB,SAAvB,EAAf;AACA,QAAA,OAAO,CAAC,KAAR,GAAgB,MAAM,CAAC,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,MAAP,GAAgB,CAAzB,EAA4B,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,OAAO,CAAC,WAApB,CAA5B,CAAD,CAAtB;AACD;;AACD,UAAI,aAAa,OAAjB,EAA0B;AACxB,QAAA,OAAO,CAAC,OAAR,GAAkB,OAAO,CAAC,OAA1B;AACD;;AACD,UAAI,YAAY,OAAhB,EAAyB;AACvB,QAAA,OAAO,CAAC,KAAR,GAAgB,OAAO,CAAC,MAAxB;AACD;;AACD,UAAI,aAAa,OAAjB,EAA0B;AACxB,QAAA,OAAO,CAAC,OAAR,GAAkB,OAAO,CAAC,OAA1B;AACD;;AACD,UAAI,aAAa,OAAjB,EAA0B;AACxB,QAAA,OAAO,CAAC,OAAR,GAAkB,OAAO,CAAC,OAA1B;AACD;;AACD,UAAI,cAAc,OAAlB,EAA2B;AACzB,QAAA,OAAO,CAAC,QAAR,GAAmB,OAAO,CAAC,QAA3B;AACD;;AACD,UAAI,YAAY,OAAhB,EAAyB;AACvB,QAAA,OAAO,CAAC,MAAR,GAAiB,OAAO,CAAC,MAAzB;AACD;;AACD,UAAI,gBAAgB,OAApB,EAA6B;AAC3B,QAAA,OAAO,CAAC,UAAR,GAAqB,OAAO,CAAC,UAA7B;AACD;;AACD,MAAA,OAAO,CAAC,IAAR,GAAe,IAAf;AACA,MAAA,MAAM,CAAC,eAAP,CAAuB,KAAvB,CAA6B,OAA7B;AAEA,aAAO,OAAP;AA9C0D;AA+C3D,GAnDY;;AAoDP,EAAA,UAAN,GAAgB;AAAA;AACd,aAAO,MAAM,CAAC,eAAP,CAAuB,QAA9B;AADc;AAEf,GAtDY;;AAuDP,EAAA,IAAN,GAAU;AAAA;AACR,aAAO,MAAM,CAAC,eAAP,CAAuB,MAAvB,EAAP;AADQ;AAET,GAzDY;;AA0DP,EAAA,KAAN,GAAW;AAAA;AACT,aAAO,MAAM,CAAC,eAAP,CAAuB,KAAvB,EAAP;AADS;AAEV,GA5DY;;AA6DP,EAAA,MAAN,GAAY;AAAA;AACV,aAAO,MAAM,CAAC,eAAP,CAAuB,MAAvB,EAAP;AADU;AAEX;;AA/DY,CAAf","sourcesContent":["import { SpeechOptions } from './Speech.types';\n\nexport default {\n  get name(): string {\n    return 'ExponentSpeech';\n  },\n  async speak(id: string, text: string, options: SpeechOptions): Promise<SpeechSynthesisUtterance> {\n    // @ts-ignore\n    const { SpeechSynthesisUtterance } = global.window;\n\n    const message = new SpeechSynthesisUtterance();\n\n    if ('rate' in options) {\n      message.rate = options.rate;\n    }\n    if ('pitch' in options) {\n      message.pitch = options.pitch;\n    }\n    if ('language' in options) {\n      message.lang = options.language;\n    }\n    if ('volume' in options) {\n      message.volume = options.volume;\n    }\n    if ('_voiceIndex' in options && options._voiceIndex != null) {\n      const voices = window.speechSynthesis.getVoices();\n      message.voice = voices[Math.min(voices.length - 1, Math.max(0, options._voiceIndex))];\n    }\n    if ('onStart' in options) {\n      message.onstart = options.onStart;\n    }\n    if ('onDone' in options) {\n      message.onend = options.onDone;\n    }\n    if ('onError' in options) {\n      message.onerror = options.onError;\n    }\n    if ('onPause' in options) {\n      message.onpause = options.onPause;\n    }\n    if ('onResume' in options) {\n      message.onresume = options.onResume;\n    }\n    if ('onMark' in options) {\n      message.onmark = options.onMark;\n    }\n    if ('onBoundary' in options) {\n      message.onboundary = options.onBoundary;\n    }\n    message.text = text;\n    window.speechSynthesis.speak(message);\n\n    return message;\n  },\n  async isSpeaking(): Promise<Boolean> {\n    return window.speechSynthesis.speaking;\n  },\n  async stop(): Promise<void> {\n    return window.speechSynthesis.cancel();\n  },\n  async pause(): Promise<void> {\n    return window.speechSynthesis.pause();\n  },\n  async resume(): Promise<void> {\n    return window.speechSynthesis.resume();\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}