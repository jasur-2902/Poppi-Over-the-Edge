{"ast":null,"code":"import { EventEmitter } from 'fbemitter';\nimport { vec2 } from 'gl-matrix';\n\nclass SignatureBezierProvider extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.nextPointIndex = 0;\n    this.points = new Array(SignatureBezierProvider.pointsPerLine).fill(SignatureBezierProvider.dotWeight).map(weight => ({\n      point: vec2.create(),\n      weight\n    }));\n  }\n\n  static signatureWeightForLine(pointA, pointB) {\n    var maxLengthRange = SignatureBezierProvider.maxWeight * 10;\n    var gradient = 0.1;\n    var constant = SignatureBezierProvider.minWeight;\n    var length = vec2.distance(pointA, pointB);\n    var inversedLength = Math.max(maxLengthRange - length, 0);\n    return inversedLength * gradient + constant;\n  }\n\n  addPointToSignature(point) {\n    var isEndOfLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (this.isFirstPoint) {\n      this.startNewLine(point, SignatureBezierProvider.dotWeight);\n    } else {\n      var previousPoint = this.previousPoint;\n\n      if (vec2.length(previousPoint, point) < SignatureBezierProvider.touchDistanceThreshold) {\n        return;\n      }\n\n      if (this.isStartOfNextLine) {\n        this.finalizeBezier(point);\n        this.startNewLine(this.points[3].point, this.points[3].weight);\n      }\n\n      this.addPointAndWeight(point, SignatureBezierProvider.signatureWeightForLine(previousPoint, point));\n    }\n\n    this.generateBezierPath(this.nextPointIndex - 1, isEndOfLine);\n  }\n\n  reset() {\n    this.nextPointIndex = 0;\n  }\n\n  finalizeBezier(point3rd) {\n    var point2nd = this.points[2].point;\n    var pointAvg = this.points[3].point;\n    vec2.scale(pointAvg, vec2.add(pointAvg, point2nd, point3rd), 0.5);\n    this.points[3].weight = SignatureBezierProvider.signatureWeightForLine(point2nd, pointAvg);\n    this.generateBezierPath(3, true);\n  }\n\n  generateBezierPath(index) {\n    var finalized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.emit(SignatureBezierProvider.EVENT_DRAW_PATH, SignatureBezierProvider.paths[index], this.points, finalized);\n  }\n\n  startNewLine(point, weight) {\n    this.nextPointIndex = 0;\n    this.addPointAndWeight(point, weight);\n  }\n\n  addPointAndWeight(point, weight) {\n    vec2.copy(this.points[this.nextPointIndex].point, point);\n    this.points[this.nextPointIndex].weight = weight;\n    this.nextPointIndex += 1;\n  }\n\n  get isFirstPoint() {\n    return this.nextPointIndex === 0;\n  }\n\n  get isStartOfNextLine() {\n    return this.nextPointIndex >= SignatureBezierProvider.pointsPerLine;\n  }\n\n  get previousPoint() {\n    return this.points[this.nextPointIndex - 1].point;\n  }\n\n}\n\nSignatureBezierProvider.dotWeight = 3;\nSignatureBezierProvider.pointsPerLine = 4;\nSignatureBezierProvider.touchDistanceThreshold = 2;\nSignatureBezierProvider.maxWeight = 10;\nSignatureBezierProvider.minWeight = 2;\nSignatureBezierProvider.paths = ['dot', 'line', 'quadCurve', 'bezierCurve'];\nSignatureBezierProvider.EVENT_DRAW_PATH = 'drawPath';\nexport default SignatureBezierProvider;","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/expo-pixi/lib/core/signature/SignatureBezierProvider.js"],"names":["EventEmitter","vec2","SignatureBezierProvider","nextPointIndex","points","Array","pointsPerLine","fill","dotWeight","map","weight","point","create","signatureWeightForLine","pointA","pointB","maxLengthRange","maxWeight","gradient","constant","minWeight","length","distance","inversedLength","Math","max","addPointToSignature","isEndOfLine","isFirstPoint","startNewLine","previousPoint","touchDistanceThreshold","isStartOfNextLine","finalizeBezier","addPointAndWeight","generateBezierPath","reset","point3rd","point2nd","pointAvg","scale","add","index","finalized","emit","EVENT_DRAW_PATH","paths","copy"],"mappings":"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","sourcesContent":["//@flow\nimport { EventEmitter } from 'fbemitter';\nimport { vec2 } from 'gl-matrix';\n\nclass SignatureBezierProvider extends EventEmitter {\n  static dotWeight = 3;\n  static pointsPerLine = 4;\n  static touchDistanceThreshold = 2;\n  static maxWeight = 10;\n  static minWeight = 2;\n\n  static paths = ['dot', 'line', 'quadCurve', 'bezierCurve'];\n\n  static EVENT_DRAW_PATH = 'drawPath';\n\n  static signatureWeightForLine(pointA, pointB) {\n    /**\n     * The is the maximum length that will vary weight.\n     * Anything higher will return the same weight.\n     */\n    const maxLengthRange = SignatureBezierProvider.maxWeight * 10;\n\n    /**\n     * These are based on having a minimum line thickness of 2.0 and maximum of 10.0,\n     * linearly over line lengths 0-maxLengthRange.\n     * They fit into a typical linear equation: y = mx + c\n     *\n     * Note: Only the points of the two parallel bezier curves will be\n     * at least as thick as the constant. The bezier curves themselves\n     * could still be drawn with sharp angles, meaning there is no true\n     * 'minimum thickness' of the signature.\n     */\n    const gradient = 0.1;\n    const constant = SignatureBezierProvider.minWeight;\n\n    const length = vec2.distance(pointA, pointB);\n    const inversedLength = Math.max(maxLengthRange - length, 0);\n    return inversedLength * gradient + constant;\n  }\n\n  nextPointIndex = 0;\n  points = new Array(SignatureBezierProvider.pointsPerLine)\n    .fill(SignatureBezierProvider.dotWeight)\n    .map(weight => ({ point: vec2.create(), weight }));\n\n  addPointToSignature(point, isEndOfLine = false) {\n    if (this.isFirstPoint) {\n      this.startNewLine(point, SignatureBezierProvider.dotWeight);\n    } else {\n      let previousPoint = this.previousPoint;\n      if (vec2.length(previousPoint, point) < SignatureBezierProvider.touchDistanceThreshold) {\n        return;\n      }\n      if (this.isStartOfNextLine) {\n        this.finalizeBezier(point);\n        this.startNewLine(this.points[3].point, this.points[3].weight);\n      }\n\n      this.addPointAndWeight(\n        point,\n        SignatureBezierProvider.signatureWeightForLine(previousPoint, point)\n      );\n    }\n\n    this.generateBezierPath(this.nextPointIndex - 1, isEndOfLine);\n  }\n\n  reset() {\n    this.nextPointIndex = 0;\n  }\n\n  finalizeBezier(point3rd) {\n    /**\n     * Smooth the join between beziers by modifying the last point of the current bezier\n     * to equal the average of the points either side of it.\n     */\n    const point2nd = this.points[2].point;\n    const pointAvg = this.points[3].point;\n    vec2.scale(pointAvg, vec2.add(pointAvg, point2nd, point3rd), 0.5);\n    this.points[3].weight = SignatureBezierProvider.signatureWeightForLine(point2nd, pointAvg);\n\n    this.generateBezierPath(3, true);\n  }\n\n  generateBezierPath(index, finalized = false) {\n    this.emit(\n      SignatureBezierProvider.EVENT_DRAW_PATH,\n      SignatureBezierProvider.paths[index],\n      this.points,\n      finalized\n    );\n  }\n\n  startNewLine(point, weight) {\n    this.nextPointIndex = 0;\n    this.addPointAndWeight(point, weight);\n  }\n\n  addPointAndWeight(point, weight) {\n    vec2.copy(this.points[this.nextPointIndex].point, point);\n    this.points[this.nextPointIndex].weight = weight;\n    this.nextPointIndex += 1;\n  }\n\n  get isFirstPoint() {\n    return this.nextPointIndex === 0;\n  }\n\n  get isStartOfNextLine() {\n    return this.nextPointIndex >= SignatureBezierProvider.pointsPerLine;\n  }\n\n  get previousPoint() {\n    return this.points[this.nextPointIndex - 1].point;\n  }\n}\n\nexport default SignatureBezierProvider;\n"]},"metadata":{},"sourceType":"module"}