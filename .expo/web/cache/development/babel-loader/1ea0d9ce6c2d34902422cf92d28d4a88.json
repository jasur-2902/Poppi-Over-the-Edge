{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { CodedError } from '@unimodules/core';\nimport { CryptoEncoding } from \"./Crypto.types\";\nexport default {\n  get name() {\n    return 'ExpoCrypto';\n  },\n\n  digestStringAsync(algorithm, data, options) {\n    return _asyncToGenerator(function* () {\n      var encoder = new TextEncoder();\n      var buffer = encoder.encode(data);\n      var hashedData = yield crypto.subtle.digest(algorithm, buffer);\n\n      if (options.encoding === CryptoEncoding.HEX) {\n        return hexString(hashedData);\n      } else if (options.encoding === CryptoEncoding.BASE64) {\n        return btoa(String.fromCharCode(...new Uint8Array(hashedData)));\n      }\n\n      throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n    })();\n  }\n\n};\n\nfunction hexString(buffer) {\n  var byteArray = new Uint8Array(buffer);\n  var hexCodes = [...byteArray].map(value => {\n    var hexCode = value.toString(16);\n    var paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n  return hexCodes.join('');\n}","map":{"version":3,"sources":["../src/ExpoCrypto.web.ts"],"names":[],"mappings":";;;;AAAA,SAAS,UAAT,QAA2B,kBAA3B;AACA,SAAgC,cAAhC;AAEA,eAAe;AACb,MAAI,IAAJ,GAAQ;AACN,WAAO,YAAP;AACD,GAHY;;AAIP,EAAA,iBAAN,CACE,SADF,EAEE,IAFF,EAGE,OAHF,EAG8B;AAAA;AAE5B,UAAM,OAAO,GAAG,IAAI,WAAJ,EAAhB;AACA,UAAM,MAAM,GAAG,OAAO,CAAC,MAAR,CAAe,IAAf,CAAf;AACA,UAAM,UAAU,SAAS,MAAM,CAAC,MAAP,CAAc,MAAd,CAAqB,SAArB,EAAgC,MAAhC,CAAzB;;AACA,UAAI,OAAO,CAAC,QAAR,KAAqB,cAAc,CAAC,GAAxC,EAA6C;AAC3C,eAAO,SAAS,CAAC,UAAD,CAAhB;AACD,OAFD,MAEO,IAAI,OAAO,CAAC,QAAR,KAAqB,cAAc,CAAC,MAAxC,EAAgD;AACrD,eAAO,IAAI,CAAC,MAAM,CAAC,YAAP,CAAoB,GAAG,IAAI,UAAJ,CAAe,UAAf,CAAvB,CAAD,CAAX;AACD;;AACD,YAAM,IAAI,UAAJ,CAAe,mBAAf,EAAoC,iCAApC,CAAN;AAV4B;AAW7B;;AAlBY,CAAf;;AAqBA,SAAS,SAAT,CAAmB,MAAnB,EAAsC;AACpC,MAAM,SAAS,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAlB;AAEA,MAAM,QAAQ,GAAG,CAAC,GAAG,SAAJ,EAAe,GAAf,CAAmB,KAAK,IAAG;AAC1C,QAAM,OAAO,GAAG,KAAK,CAAC,QAAN,CAAe,EAAf,CAAhB;AACA,QAAM,aAAa,GAAG,OAAO,CAAC,QAAR,CAAiB,CAAjB,EAAoB,GAApB,CAAtB;AACA,WAAO,aAAP;AACD,GAJgB,CAAjB;AAMA,SAAO,QAAQ,CAAC,IAAT,CAAc,EAAd,CAAP;AACD","sourcesContent":["import { CodedError } from '@unimodules/core';\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions } from './Crypto.types';\n\nexport default {\n  get name(): string {\n    return 'ExpoCrypto';\n  },\n  async digestStringAsync(\n    algorithm: CryptoDigestAlgorithm,\n    data: string,\n    options: CryptoDigestOptions\n  ): Promise<string> {\n    const encoder = new TextEncoder();\n    const buffer = encoder.encode(data);\n    const hashedData = await crypto.subtle.digest(algorithm, buffer);\n    if (options.encoding === CryptoEncoding.HEX) {\n      return hexString(hashedData);\n    } else if (options.encoding === CryptoEncoding.BASE64) {\n      return btoa(String.fromCharCode(...new Uint8Array(hashedData)));\n    }\n    throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n  },\n};\n\nfunction hexString(buffer: ArrayBuffer): string {\n  const byteArray = new Uint8Array(buffer);\n\n  const hexCodes = [...byteArray].map(value => {\n    const hexCode = value.toString(16);\n    const paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n\n  return hexCodes.join('');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}