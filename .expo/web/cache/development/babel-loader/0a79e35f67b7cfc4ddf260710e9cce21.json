{"ast":null,"code":"function chunkArray() {\n  var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var size = arguments.length > 1 ? arguments[1] : undefined;\n  if (array === []) return [];\n  return array.reduce((acc, val) => {\n    if (acc.length === 0) acc.push([]);\n    var last = acc[acc.length - 1];\n\n    if (last.length < size) {\n      last.push(val);\n    } else {\n      acc.push([val]);\n    }\n\n    return acc;\n  }, []);\n}\n\nfunction calculateDimensions(_ref) {\n  var {\n    itemDimension,\n    staticDimension,\n    totalDimension,\n    fixed,\n    spacing\n  } = _ref;\n  var usableTotalDimension = staticDimension || totalDimension;\n  var availableDimension = usableTotalDimension - spacing;\n  var itemTotalDimension = Math.min(itemDimension + spacing, availableDimension);\n  var itemsPerRow = Math.floor(availableDimension / itemTotalDimension);\n  var containerDimension = availableDimension / itemsPerRow;\n  var fixedSpacing;\n\n  if (fixed) {\n    fixedSpacing = (totalDimension - itemDimension * itemsPerRow) / (itemsPerRow + 1);\n  }\n\n  return {\n    itemTotalDimension,\n    availableDimension,\n    itemsPerRow,\n    containerDimension,\n    fixedSpacing\n  };\n}\n\nfunction generateStyles(_ref2) {\n  var {\n    itemDimension,\n    containerDimension,\n    spacing,\n    fixed,\n    horizontal,\n    fixedSpacing\n  } = _ref2;\n  var rowStyle = {\n    flexDirection: 'row',\n    paddingLeft: fixed ? fixedSpacing : spacing,\n    paddingBottom: spacing\n  };\n  var containerStyle = {\n    flexDirection: 'column',\n    justifyContent: 'center',\n    width: fixed ? itemDimension : containerDimension - spacing,\n    marginRight: fixed ? fixedSpacing : spacing\n  };\n\n  if (horizontal) {\n    rowStyle = {\n      flexDirection: 'column',\n      paddingTop: fixed ? fixedSpacing : spacing,\n      paddingRight: spacing\n    };\n    containerStyle = {\n      flexDirection: 'row',\n      justifyContent: 'center',\n      height: fixed ? itemDimension : containerDimension - spacing,\n      marginBottom: fixed ? fixedSpacing : spacing\n    };\n  }\n\n  return {\n    containerStyle,\n    rowStyle\n  };\n}\n\nexport { chunkArray, calculateDimensions, generateStyles };","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/react-native-super-grid/utils.js"],"names":["chunkArray","array","size","reduce","acc","val","length","push","last","calculateDimensions","itemDimension","staticDimension","totalDimension","fixed","spacing","usableTotalDimension","availableDimension","itemTotalDimension","Math","min","itemsPerRow","floor","containerDimension","fixedSpacing","generateStyles","horizontal","rowStyle","flexDirection","paddingLeft","paddingBottom","containerStyle","justifyContent","width","marginRight","paddingTop","paddingRight","height","marginBottom"],"mappings":"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","sourcesContent":["\nfunction chunkArray(array = [], size) {\n  if (array === []) return [];\n  return array.reduce((acc, val) => {\n    if (acc.length === 0) acc.push([]);\n    const last = acc[acc.length - 1];\n    if (last.length < size) {\n      last.push(val);\n    } else {\n      acc.push([val]);\n    }\n    return acc;\n  }, []);\n}\n\nfunction calculateDimensions({\n  itemDimension,\n  staticDimension,\n  totalDimension,\n  fixed,\n  spacing,\n}) {\n  const usableTotalDimension = staticDimension || totalDimension;\n  const availableDimension = usableTotalDimension - spacing; // One spacing extra\n  const itemTotalDimension = Math.min(itemDimension + spacing, availableDimension); // itemTotalDimension should not exceed availableDimension\n  const itemsPerRow = Math.floor(availableDimension / itemTotalDimension);\n  const containerDimension = availableDimension / itemsPerRow;\n\n  let fixedSpacing;\n  if (fixed) {\n    fixedSpacing = (totalDimension - (itemDimension * itemsPerRow)) / (itemsPerRow + 1);\n  }\n\n  return {\n    itemTotalDimension,\n    availableDimension,\n    itemsPerRow,\n    containerDimension,\n    fixedSpacing,\n  };\n}\n\nfunction generateStyles({\n  itemDimension,\n  containerDimension,\n  spacing,\n  fixed,\n  horizontal,\n  fixedSpacing,\n}) {\n  let rowStyle = {\n    flexDirection: 'row',\n    paddingLeft: fixed ? fixedSpacing : spacing,\n    paddingBottom: spacing,\n  };\n\n  let containerStyle = {\n    flexDirection: 'column',\n    justifyContent: 'center',\n    width: fixed ? itemDimension : (containerDimension - spacing),\n    marginRight: fixed ? fixedSpacing : spacing,\n  };\n\n  if (horizontal) {\n    rowStyle = {\n      flexDirection: 'column',\n      paddingTop: fixed ? fixedSpacing : spacing,\n      paddingRight: spacing,\n    };\n\n    containerStyle = {\n      flexDirection: 'row',\n      justifyContent: 'center',\n      height: fixed ? itemDimension : (containerDimension - spacing),\n      marginBottom: fixed ? fixedSpacing : spacing,\n    };\n  }\n\n  return {\n    containerStyle,\n    rowStyle,\n  };\n}\n\nexport { chunkArray, calculateDimensions, generateStyles };\n"]},"metadata":{},"sourceType":"module"}