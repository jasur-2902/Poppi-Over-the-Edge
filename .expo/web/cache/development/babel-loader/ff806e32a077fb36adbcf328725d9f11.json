{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { EventEmitter } from '@unimodules/core';\nimport { UnavailabilityError } from '@unimodules/core';\nimport ExpoTaskManager from \"./ExpoTaskManager\";\nvar eventEmitter = new EventEmitter(ExpoTaskManager);\nvar tasks = new Map();\nvar isRunningDuringInitialization = true;\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.');\n  }\n}\n\nexport function defineTask(taskName, task) {\n  if (!isRunningDuringInitialization) {\n    console.error(\"TaskManager.defineTask must be called during initialization phase!\");\n    return;\n  }\n\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(\"TaskManager.defineTask: 'taskName' argument must be a non-empty string.\");\n    return;\n  }\n\n  if (!task || typeof task !== 'function') {\n    console.warn(\"TaskManager.defineTask: 'task' argument must be a function.\");\n    return;\n  }\n\n  if (tasks.has(taskName)) {\n    console.warn(\"TaskManager.defineTask: task '\".concat(taskName, \"' is already defined.\"));\n    return;\n  }\n\n  tasks.set(taskName, task);\n}\nexport function isTaskDefined(taskName) {\n  return tasks.has(taskName);\n}\nexport function isTaskRegisteredAsync(_x) {\n  return _isTaskRegisteredAsync.apply(this, arguments);\n}\n\nfunction _isTaskRegisteredAsync() {\n  _isTaskRegisteredAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoTaskManager.isTaskRegisteredAsync) {\n      throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync');\n    }\n\n    _validateTaskName(taskName);\n\n    return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n  });\n  return _isTaskRegisteredAsync.apply(this, arguments);\n}\n\nexport function getTaskOptionsAsync(_x2) {\n  return _getTaskOptionsAsync.apply(this, arguments);\n}\n\nfunction _getTaskOptionsAsync() {\n  _getTaskOptionsAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoTaskManager.getTaskOptionsAsync) {\n      throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync');\n    }\n\n    _validateTaskName(taskName);\n\n    return ExpoTaskManager.getTaskOptionsAsync(taskName);\n  });\n  return _getTaskOptionsAsync.apply(this, arguments);\n}\n\nexport function getRegisteredTasksAsync() {\n  return _getRegisteredTasksAsync.apply(this, arguments);\n}\n\nfunction _getRegisteredTasksAsync() {\n  _getRegisteredTasksAsync = _asyncToGenerator(function* () {\n    if (!ExpoTaskManager.getRegisteredTasksAsync) {\n      throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync');\n    }\n\n    return ExpoTaskManager.getRegisteredTasksAsync();\n  });\n  return _getRegisteredTasksAsync.apply(this, arguments);\n}\n\nexport function unregisterTaskAsync(_x3) {\n  return _unregisterTaskAsync.apply(this, arguments);\n}\n\nfunction _unregisterTaskAsync() {\n  _unregisterTaskAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoTaskManager.unregisterTaskAsync) {\n      throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync');\n    }\n\n    _validateTaskName(taskName);\n\n    yield ExpoTaskManager.unregisterTaskAsync(taskName);\n  });\n  return _unregisterTaskAsync.apply(this, arguments);\n}\n\nexport function unregisterAllTasksAsync() {\n  return _unregisterAllTasksAsync.apply(this, arguments);\n}\n\nfunction _unregisterAllTasksAsync() {\n  _unregisterAllTasksAsync = _asyncToGenerator(function* () {\n    if (!ExpoTaskManager.unregisterAllTasksAsync) {\n      throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync');\n    }\n\n    yield ExpoTaskManager.unregisterAllTasksAsync();\n  });\n  return _unregisterAllTasksAsync.apply(this, arguments);\n}\n\neventEmitter.addListener(ExpoTaskManager.EVENT_NAME, function () {\n  var _ref2 = _asyncToGenerator(function* (_ref) {\n    var {\n      data,\n      error,\n      executionInfo\n    } = _ref;\n    var {\n      eventId,\n      taskName\n    } = executionInfo;\n    var task = tasks.get(taskName);\n    var result = null;\n\n    if (task) {\n      try {\n        result = yield task({\n          data,\n          error,\n          executionInfo\n        });\n      } catch (error) {\n        console.error(\"TaskManager: Task \\\"\".concat(taskName, \"\\\" failed:\"), error);\n      } finally {\n        yield ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n          eventId,\n          result\n        });\n      }\n    } else {\n      console.warn(\"TaskManager: Task \\\"\".concat(taskName, \"\\\" has been executed but looks like it is not defined. Please make sure that \\\"TaskManager.defineTask\\\" is called during initialization phase.\"));\n      yield ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n        eventId,\n        result\n      });\n      yield ExpoTaskManager.unregisterTaskAsync(taskName);\n    }\n  });\n\n  return function (_x4) {\n    return _ref2.apply(this, arguments);\n  };\n}());\nPromise.resolve().then(() => {\n  isRunningDuringInitialization = false;\n});","map":{"version":3,"sources":["../src/TaskManager.ts"],"names":[],"mappings":";;;;AAAA,SAAS,YAAT,QAA6B,kBAA7B;AACA,SAAS,mBAAT,QAAoC,kBAApC;AACA,OAAO,eAAP;AAwBA,IAAM,YAAY,GAAG,IAAI,YAAJ,CAAiB,eAAjB,CAArB;AACA,IAAM,KAAK,GAAsB,IAAI,GAAJ,EAAjC;AAEA,IAAI,6BAA6B,GAAG,IAApC;;AAEA,SAAS,iBAAT,CAA2B,QAA3B,EAAmC;AACjC,MAAI,CAAC,QAAD,IAAa,OAAO,QAAP,KAAoB,QAArC,EAA+C;AAC7C,UAAM,IAAI,SAAJ,CAAc,wCAAd,CAAN;AACD;AACF;;AAED,OAAM,SAAU,UAAV,CAAqB,QAArB,EAAuC,IAAvC,EAAiD;AACrD,MAAI,CAAC,6BAAL,EAAoC;AAClC,IAAA,OAAO,CAAC,KAAR;AACA;AACD;;AACD,MAAI,CAAC,QAAD,IAAa,OAAO,QAAP,KAAoB,QAArC,EAA+C;AAC7C,IAAA,OAAO,CAAC,IAAR;AACA;AACD;;AACD,MAAI,CAAC,IAAD,IAAS,OAAO,IAAP,KAAgB,UAA7B,EAAyC;AACvC,IAAA,OAAO,CAAC,IAAR;AACA;AACD;;AACD,MAAI,KAAK,CAAC,GAAN,CAAU,QAAV,CAAJ,EAAyB;AACvB,IAAA,OAAO,CAAC,IAAR,yCAA8C,QAA9C;AACA;AACD;;AACD,EAAA,KAAK,CAAC,GAAN,CAAU,QAAV,EAAoB,IAApB;AACD;AAED,OAAM,SAAU,aAAV,CAAwB,QAAxB,EAAwC;AAC5C,SAAO,KAAK,CAAC,GAAN,CAAU,QAAV,CAAP;AACD;AAED,gBAAsB,qBAAtB;AAAA;AAAA;;;6CAAO,WAAqC,QAArC,EAAqD;AAC1D,QAAI,CAAC,eAAe,CAAC,qBAArB,EAA4C;AAC1C,YAAM,IAAI,mBAAJ,CAAwB,aAAxB,EAAuC,uBAAvC,CAAN;AACD;;AAED,IAAA,iBAAiB,CAAC,QAAD,CAAjB;;AACA,WAAO,eAAe,CAAC,qBAAhB,CAAsC,QAAtC,CAAP;AACD,G;;;;AAED,gBAAsB,mBAAtB;AAAA;AAAA;;;2CAAO,WAAgD,QAAhD,EAAgE;AACrE,QAAI,CAAC,eAAe,CAAC,mBAArB,EAA0C;AACxC,YAAM,IAAI,mBAAJ,CAAwB,aAAxB,EAAuC,qBAAvC,CAAN;AACD;;AAED,IAAA,iBAAiB,CAAC,QAAD,CAAjB;;AACA,WAAO,eAAe,CAAC,mBAAhB,CAAoC,QAApC,CAAP;AACD,G;;;;AAED,gBAAsB,uBAAtB;AAAA;AAAA;;;+CAAO,aAAsC;AAC3C,QAAI,CAAC,eAAe,CAAC,uBAArB,EAA8C;AAC5C,YAAM,IAAI,mBAAJ,CAAwB,aAAxB,EAAuC,yBAAvC,CAAN;AACD;;AAED,WAAO,eAAe,CAAC,uBAAhB,EAAP;AACD,G;;;;AAED,gBAAsB,mBAAtB;AAAA;AAAA;;;2CAAO,WAAmC,QAAnC,EAAmD;AACxD,QAAI,CAAC,eAAe,CAAC,mBAArB,EAA0C;AACxC,YAAM,IAAI,mBAAJ,CAAwB,aAAxB,EAAuC,qBAAvC,CAAN;AACD;;AAED,IAAA,iBAAiB,CAAC,QAAD,CAAjB;;AACA,UAAM,eAAe,CAAC,mBAAhB,CAAoC,QAApC,CAAN;AACD,G;;;;AAED,gBAAsB,uBAAtB;AAAA;AAAA;;;+CAAO,aAAsC;AAC3C,QAAI,CAAC,eAAe,CAAC,uBAArB,EAA8C;AAC5C,YAAM,IAAI,mBAAJ,CAAwB,aAAxB,EAAuC,yBAAvC,CAAN;AACD;;AAED,UAAM,eAAe,CAAC,uBAAhB,EAAN;AACD,G;;;;AAED,YAAY,CAAC,WAAb,CAAmC,eAAe,CAAC,UAAnD;AAAA,gCAA+D,iBAAyC;AAAA,QAAlC;AAAE,MAAA,IAAF;AAAQ,MAAA,KAAR;AAAe,MAAA;AAAf,KAAkC;AACtG,QAAM;AAAE,MAAA,OAAF;AAAW,MAAA;AAAX,QAAwB,aAA9B;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,GAAN,CAAU,QAAV,CAAb;AACA,QAAI,MAAM,GAAQ,IAAlB;;AAEA,QAAI,IAAJ,EAAU;AACR,UAAI;AAEF,QAAA,MAAM,SAAS,IAAI,CAAC;AAAE,UAAA,IAAF;AAAQ,UAAA,KAAR;AAAe,UAAA;AAAf,SAAD,CAAnB;AACD,OAHD,CAGE,OAAO,KAAP,EAAc;AACd,QAAA,OAAO,CAAC,KAAR,+BAAoC,QAApC,iBAAyD,KAAzD;AACD,OALD,SAKU;AAER,cAAM,eAAe,CAAC,uBAAhB,CAAwC,QAAxC,EAAkD;AAAE,UAAA,OAAF;AAAW,UAAA;AAAX,SAAlD,CAAN;AACD;AACF,KAVD,MAUO;AACL,MAAA,OAAO,CAAC,IAAR,+BAAmC,QAAnC;AAEA,YAAM,eAAe,CAAC,uBAAhB,CAAwC,QAAxC,EAAkD;AAAE,QAAA,OAAF;AAAW,QAAA;AAAX,OAAlD,CAAN;AAGA,YAAM,eAAe,CAAC,mBAAhB,CAAoC,QAApC,CAAN;AACD;AACF,GAvBD;;AAAA;AAAA;AAAA;AAAA;AA2BA,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAAuB,MAAK;AAC1B,EAAA,6BAA6B,GAAG,KAAhC;AACD,CAFD","sourcesContent":["import { EventEmitter } from '@unimodules/core';\nimport { UnavailabilityError } from '@unimodules/core';\nimport ExpoTaskManager from './ExpoTaskManager';\n\ninterface TaskError {\n  code: string | number,\n  message: string,\n}\n\ninterface TaskBody {\n  data: object,\n  error: TaskError | null,\n  executionInfo: {\n    eventId: string,\n    taskName: string,\n  },\n}\n\nexport interface RegisteredTask {\n  taskName: string,\n  taskType: string,\n  options: any,\n}\n\ntype Task = (body: TaskBody) => void;\n\nconst eventEmitter = new EventEmitter(ExpoTaskManager);\nconst tasks: Map<string, Task> = new Map<string, Task>();\n\nlet isRunningDuringInitialization = true;\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.')\n  }\n}\n\nexport function defineTask(taskName: string, task: Task) {\n  if (!isRunningDuringInitialization) {\n    console.error(`TaskManager.defineTask must be called during initialization phase!`);\n    return;\n  }\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n  if (!task || typeof task !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n  if (tasks.has(taskName)) {\n    console.warn(`TaskManager.defineTask: task '${taskName}' is already defined.`);\n    return;\n  }\n  tasks.set(taskName, task);\n}\n\nexport function isTaskDefined(taskName: string): boolean {\n  return tasks.has(taskName);\n}\n\nexport async function isTaskRegisteredAsync(taskName: string): Promise<boolean> {\n  if (!ExpoTaskManager.isTaskRegisteredAsync) {\n    throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync')\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n}\n\nexport async function getTaskOptionsAsync<TaskOptions>(taskName: string): Promise<TaskOptions> {\n  if (!ExpoTaskManager.getTaskOptionsAsync) {\n    throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync')\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.getTaskOptionsAsync(taskName);\n}\n\nexport async function getRegisteredTasksAsync(): Promise<RegisteredTask[]> {\n  if (!ExpoTaskManager.getRegisteredTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync')\n  }\n\n  return ExpoTaskManager.getRegisteredTasksAsync();\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoTaskManager.unregisterTaskAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync')\n  }\n\n  _validateTaskName(taskName);\n  await ExpoTaskManager.unregisterTaskAsync(taskName);\n}\n\nexport async function unregisterAllTasksAsync(): Promise<void> {\n  if (!ExpoTaskManager.unregisterAllTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync')\n  }\n\n  await ExpoTaskManager.unregisterAllTasksAsync();\n}\n\neventEmitter.addListener<TaskBody>(ExpoTaskManager.EVENT_NAME, async ({ data, error, executionInfo }) => {\n  const { eventId, taskName } = executionInfo;\n  const task = tasks.get(taskName);\n  let result: any = null;\n\n  if (task) {\n    try {\n      // Execute JS task\n      result = await task({ data, error, executionInfo });\n    } catch (error) {\n      console.error(`TaskManager: Task \"${taskName}\" failed:`, error);\n    } finally {\n      // Notify manager the task is finished.\n      await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n    }\n  } else {\n    console.warn(`TaskManager: Task \"${taskName}\" has been executed but looks like it is not defined. Please make sure that \"TaskManager.defineTask\" is called during initialization phase.`);\n    // No tasks defined -> we need to notify about finish anyway.\n    await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n    // We should also unregister such tasks automatically as the task might have been removed\n    // from the app or just renamed - in that case it needs to be registered again (with the new name).\n    await ExpoTaskManager.unregisterTaskAsync(taskName);\n  }\n});\n\n// @tsapeta: Turn off `defineTask` function right after the initialization phase.\n// Promise.resolve() ensures that it will be called as a microtask just after the first event loop.\nPromise.resolve().then(() => {\n  isRunningDuringInitialization = false;\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}