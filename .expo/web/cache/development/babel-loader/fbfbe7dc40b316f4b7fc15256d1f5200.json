{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { isDataUrl, getMimeTypeFromSource, getEscapedString, resolveUrl, getSourceAndEncodeAsync, formatDataAsUrl } from \"./Utils.web\";\nvar URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\nexport function shouldProcess(string) {\n  if (!string.search) {\n    return false;\n  }\n\n  return string.search(URL_REGEX) !== -1;\n}\nexport function batchProcessAllSourcesAsync(_x, _x2, _x3) {\n  return _batchProcessAllSourcesAsync.apply(this, arguments);\n}\n\nfunction _batchProcessAllSourcesAsync() {\n  _batchProcessAllSourcesAsync = _asyncToGenerator(function* (string, baseUrl, get) {\n    if (!shouldProcess(string)) {\n      return string;\n    }\n\n    var urls = readURLs(string);\n    var done = Promise.resolve(string);\n\n    var _loop = function _loop(url) {\n      done = done.then(string => processURLAsync(string, url, baseUrl, get));\n    };\n\n    for (var url of urls) {\n      _loop(url);\n    }\n\n    return done;\n  });\n  return _batchProcessAllSourcesAsync.apply(this, arguments);\n}\n\nfunction readURLs(urls) {\n  var result = [];\n  var match;\n\n  while ((match = URL_REGEX.exec(urls)) !== null) {\n    result.push(match[1]);\n  }\n\n  return result.filter(url => !isDataUrl(url));\n}\n\nfunction processURLAsync(_x4, _x5) {\n  return _processURLAsync.apply(this, arguments);\n}\n\nfunction _processURLAsync() {\n  _processURLAsync = _asyncToGenerator(function* (string, url) {\n    var baseUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    var getSourceAsync = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getSourceAndEncodeAsync;\n    var finalURL = baseUrl ? resolveUrl(url, baseUrl) : url;\n    var data = yield getSourceAsync(finalURL);\n    var dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(url));\n    return string.replace(URLAsRegex(url), \"$1\".concat(dataUrl, \"$3\"));\n  });\n  return _processURLAsync.apply(this, arguments);\n}\n\nfunction URLAsRegex(url) {\n  return new RegExp(\"(url\\\\(['\\\"]?)(\".concat(getEscapedString(url), \")(['\\\"]?\\\\))\"), 'g');\n}","map":{"version":3,"sources":["../../src/takeSnapshotAsync/ProcessSources.web.ts"],"names":[],"mappings":";;;;AAAA,SACE,SADF,EAEE,qBAFF,EAGE,gBAHF,EAIE,UAJF,EAKE,uBALF,EAME,eANF;AASA,IAAM,SAAS,GAAG,6BAAlB;AAEA,OAAM,SAAU,aAAV,CAAwB,MAAxB,EAAsC;AAC1C,MAAI,CAAC,MAAM,CAAC,MAAZ,EAAoB;AAClB,WAAO,KAAP;AACD;;AACD,SAAO,MAAM,CAAC,MAAP,CAAc,SAAd,MAA6B,CAAC,CAArC;AACD;AAED,gBAAsB,2BAAtB;AAAA;AAAA;;;mDAAO,WACL,MADK,EAEL,OAFK,EAGL,GAHK,EAGD;AAEJ,QAAI,CAAC,aAAa,CAAC,MAAD,CAAlB,EAA4B;AAC1B,aAAO,MAAP;AACD;;AAED,QAAM,IAAI,GAAG,QAAQ,CAAC,MAAD,CAArB;AAEA,QAAI,IAAI,GAAG,OAAO,CAAC,OAAR,CAAgB,MAAhB,CAAX;;AARI,+BASO,GATP;AAUF,MAAA,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,MAAM,IAAI,eAAe,CAAC,MAAD,EAAS,GAAT,EAAc,OAAd,EAAuB,GAAvB,CAAnC,CAAP;AAVE;;AASJ,SAAK,IAAM,GAAX,IAAkB,IAAlB,EAAwB;AAAA,YAAb,GAAa;AAEvB;;AACD,WAAO,IAAP;AACD,G;;;;AAED,SAAS,QAAT,CAAkB,IAAlB,EAA8B;AAC5B,MAAM,MAAM,GAAe,EAA3B;AACA,MAAI,KAAJ;;AACA,SAAO,CAAC,KAAK,GAAG,SAAS,CAAC,IAAV,CAAe,IAAf,CAAT,MAAmC,IAA1C,EAAgD;AAC9C,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,CAAD,CAAjB;AACD;;AACD,SAAO,MAAM,CAAC,MAAP,CAAc,GAAG,IAAI,CAAC,SAAS,CAAC,GAAD,CAA/B,CAAP;AACD;;SAIc,e;;;;;uCAAf,WACE,MADF,EAEE,GAFF,EAIyD;AAAA,QADvD,OACuD,uEADzB,SACyB;AAAA,QAAvD,cAAuD,uEAAvB,uBAAuB;AAEvD,QAAM,QAAQ,GAAG,OAAO,GAAG,UAAU,CAAC,GAAD,EAAM,OAAN,CAAb,GAA8B,GAAtD;AACA,QAAM,IAAI,SAAS,cAAc,CAAC,QAAD,CAAjC;AACA,QAAM,OAAO,GAAG,eAAe,CAAC,IAAD,EAAO,qBAAqB,CAAC,GAAD,CAA5B,CAA/B;AAEA,WAAO,MAAM,CAAC,OAAP,CAAe,UAAU,CAAC,GAAD,CAAzB,cAAqC,OAArC,QAAP;AACD,G;;;;AAED,SAAS,UAAT,CAAoB,GAApB,EAAuB;AACrB,SAAO,IAAI,MAAJ,0BAA4B,gBAAgB,CAAC,GAAD,CAA5C,mBAAgE,GAAhE,CAAP;AACD","sourcesContent":["import {\n  isDataUrl,\n  getMimeTypeFromSource,\n  getEscapedString,\n  resolveUrl,\n  getSourceAndEncodeAsync,\n  formatDataAsUrl,\n} from './Utils.web';\n\nconst URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n\nexport function shouldProcess(string: string): boolean {\n  if (!string.search) {\n    return false;\n  }\n  return string.search(URL_REGEX) !== -1;\n}\n\nexport async function batchProcessAllSourcesAsync(\n  string: string,\n  baseUrl?: string,\n  get?\n): Promise<string> {\n  if (!shouldProcess(string)) {\n    return string;\n  }\n\n  const urls = readURLs(string);\n\n  let done = Promise.resolve(string);\n  for (const url of urls) {\n    done = done.then(string => processURLAsync(string, url, baseUrl, get));\n  }\n  return done;\n}\n\nfunction readURLs(urls: string): Array<any> {\n  const result: Array<any> = [];\n  let match;\n  while ((match = URL_REGEX.exec(urls)) !== null) {\n    result.push(match[1]);\n  }\n  return result.filter(url => !isDataUrl(url));\n}\n\ntype SourceHandler = (value: string) => Promise<string>;\n\nasync function processURLAsync(\n  string: string,\n  url: string,\n  baseUrl: string | undefined = undefined,\n  getSourceAsync: SourceHandler = getSourceAndEncodeAsync\n): Promise<string> {\n  const finalURL = baseUrl ? resolveUrl(url, baseUrl) : url;\n  const data = await getSourceAsync(finalURL);\n  const dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(url));\n\n  return string.replace(URLAsRegex(url), `$1${dataUrl}$3`);\n}\n\nfunction URLAsRegex(url) {\n  return new RegExp(`(url\\\\(['\"]?)(${getEscapedString(url)})(['\"]?\\\\))`, 'g');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}