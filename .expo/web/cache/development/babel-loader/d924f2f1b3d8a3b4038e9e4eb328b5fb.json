{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport AssetRegistry from 'react-native/Libraries/Image/AssetRegistry';\nimport AssetSourceResolver from 'react-native/Libraries/Image/AssetSourceResolver';\nimport resolveAssetSource from 'react-native/Libraries/Image/resolveAssetSource';\nimport uriparser from 'uri-parser';\nimport urljoin from 'url-join';\nvar FS, Constants;\n\ntry {\n  FS = require('expo-file-system').FileSystem;\n} catch (error) {\n  throw new Error('`expo-asset` requires `expo-file-system` package to be installed and linked.');\n}\n\ntry {\n  Constants = require('expo-constants').default;\n} catch (error) {\n  throw new Error('`expo-asset` requires `expo-constants` package to be installed and linked.');\n}\n\nvar parser = new uriparser.Parser();\nvar bundledAssets = new Set(FS.bundledAssets || []);\nvar assetMapOverride = Constants.manifest && Constants.manifest.assetMapOverride;\n\nvar getManifestBaseUrl = manifestUrl => {\n  var urlComponents = parser.parse(manifestUrl);\n\n  if (urlComponents.protocol === 'exp') {\n    urlComponents.protocol = 'http';\n  } else if (urlComponents.protocol === 'exps') {\n    urlComponents.protocol = 'https';\n  }\n\n  urlComponents.relative = urlComponents.directory;\n  return parser.format(urlComponents);\n};\n\nvar manifestBaseUrl = Constants.experienceUrl ? getManifestBaseUrl(Constants.experienceUrl) : null;\n\nvar resolveIfRelative = uri => {\n  var uriComponents = parser.parse(uri);\n\n  if (uriComponents.protocol === '' && manifestBaseUrl) {\n    return urljoin(manifestBaseUrl, uri.replace(/^\\.?\\//, ''));\n  } else {\n    return uri;\n  }\n};\n\nfunction isImageType(type) {\n  return /^(jpeg|jpg|gif|png|bmp)$/i.test(type);\n}\n\nfunction getExtension(url) {\n  var filename = filenameFromUrl(url);\n  var dotIndex = filename.lastIndexOf('.');\n  return dotIndex > 0 ? filename.substring(dotIndex) : '';\n}\n\nfunction filenameFromUrl(url) {\n  var urlComponents = parser.parse(this.uri);\n  return urlComponents.file;\n}\n\nvar pickScale = originalMeta => {\n  var meta = assetMapOverride ? _objectSpread(_objectSpread({}, originalMeta), assetMapOverride[originalMeta.hash]) : originalMeta;\n  var scale = meta.scales.length > 1 ? AssetSourceResolver.pickScale(meta.scales, PixelRatio.get()) : 1;\n  var index = meta.scales.findIndex(s => s === scale);\n  var hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n  var uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  var suffix = '/' + meta.name + (scale === 1 ? '' : '@' + scale + 'x') + '.' + meta.type + '?platform=' + Platform.OS + '&hash=' + meta.hash;\n\n  if (uri) {\n    return {\n      uri: resolveIfRelative(uri),\n      hash\n    };\n  }\n\n  var assetUrlOverride = Constants.manifest && Constants.manifest.assetUrlOverride;\n\n  if (assetUrlOverride) {\n    return {\n      uri: resolveIfRelative(urljoin(assetUrlOverride, hash)),\n      hash\n    };\n  }\n\n  if (/^https?:/.test(meta.httpServerLocation)) {\n    return {\n      uri: meta.httpServerLocation + suffix,\n      hash\n    };\n  }\n\n  if (Constants.manifest && Constants.manifest.developer) {\n    return {\n      uri: Constants.manifest.bundleUrl.match(/^https?:\\/\\/.*?\\//)[0] + meta.httpServerLocation.replace(/^\\/?/, '') + suffix,\n      hash\n    };\n  }\n\n  return {\n    uri: 'https://d1wp6m56sqw74a.cloudfront.net/~assets/' + hash,\n    hash\n  };\n};\n\nvar getUriInBundle = (hash, type) => {\n  var assetName = 'asset_' + hash + (type ? '.' + type : '');\n\n  if (__DEV__ || Constants.appOwnership !== 'standalone' || !bundledAssets.has(assetName)) {\n    return null;\n  }\n\n  return \"\".concat(FS.bundleDirectory).concat(assetName);\n};\n\nfunction getImageInfoAsync(src) {\n  return new Promise((resolve, reject) => {\n    var img = new Image();\n    img.onerror = reject;\n\n    img.onload = () => {\n      var name = img.name || img.title || img.localName;\n      resolve({\n        name,\n        width: img.naturalWidth,\n        height: img.naturalHeight\n      });\n    };\n\n    img.src = src;\n  });\n}\n\nexport default class Asset {\n  constructor(_ref) {\n    var {\n      name,\n      type,\n      hash,\n      uri,\n      width,\n      height\n    } = _ref;\n    this.name = name;\n    this.type = type;\n    this.hash = hash;\n    this.uri = uri;\n    this.localUri = getUriInBundle(hash, type);\n\n    if (typeof width === 'number') {\n      this.width = width;\n    }\n\n    if (typeof height === 'number') {\n      this.height = height;\n    }\n\n    this.downloading = false;\n    this.downloaded = !!this.localUri;\n    this.downloadCallbacks = [];\n  }\n\n  static loadAsync(moduleId) {\n    var moduleIds = typeof moduleId === 'number' ? [moduleId] : moduleId;\n    return Promise.all(moduleIds.map(m => Asset.fromModule(m).downloadAsync()));\n  }\n\n  static fromModule(virtualAssetModule) {\n    if (typeof virtualAssetModule === 'string') {\n      return Asset.fromURI(virtualAssetModule);\n    } else {\n      var meta = AssetRegistry.getAssetByID(virtualAssetModule);\n      return Asset.fromMetadata(meta);\n    }\n  }\n\n  static fromMetadata(meta) {\n    var metaHash = meta.hash;\n\n    if (Asset.byHash[metaHash]) {\n      return Asset.byHash[metaHash];\n    }\n\n    var {\n      uri,\n      hash\n    } = pickScale(meta);\n    var asset = new Asset({\n      name: meta.name,\n      type: meta.type,\n      hash,\n      uri,\n      width: meta.width,\n      height: meta.height\n    });\n    Asset.byHash[metaHash] = asset;\n    return asset;\n  }\n\n  static fromURI(uri) {\n    if (Asset.byUri[uri]) {\n      return Asset.byUri[uri];\n    }\n\n    var type = '';\n\n    if (uri.indexOf(';base64') > -1) {\n      type = uri.split(';')[0].split('/')[1];\n    } else {\n      type = getExtension(uri);\n    }\n\n    var asset = new Asset({\n      type,\n      uri\n    });\n    Asset.byUri[uri] = asset;\n    return asset;\n  }\n\n  downloadAsync() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.downloaded) {\n        return;\n      }\n\n      if (_this.downloading) {\n        yield new Promise((resolve, reject) => _this.downloadCallbacks.push({\n          resolve,\n          reject\n        }));\n        return;\n      }\n\n      _this.downloading = true;\n\n      try {\n        if (Platform.OS === 'web') {\n          if (isImageType(_this.type)) {\n            var {\n              width,\n              height,\n              name\n            } = yield getImageInfoAsync(_this.uri);\n            _this.width = width;\n            _this.height = height;\n            _this.name = name;\n          } else {\n            _this.name = filenameFromUrl(_this.uri);\n          }\n\n          _this.localUri = _this.uri;\n        } else {\n          var localUri = \"\".concat(FS.cacheDirectory, \"ExponentAsset-\").concat(_this.hash, \".\").concat(_this.type);\n          var {\n            exists,\n            md5\n          } = yield FS.getInfoAsync(localUri, {\n            cache: true,\n            md5: true\n          });\n\n          if (!exists || md5 !== _this.hash) {\n            ({\n              md5\n            } = yield FS.downloadAsync(_this.uri, localUri, {\n              cache: true,\n              md5: true\n            }));\n\n            if (md5 !== _this.hash) {\n              throw new Error(\"Downloaded file for asset '\".concat(_this.name, \".\").concat(_this.type, \"' \") + \"Located at \".concat(_this.uri, \" \") + \"failed MD5 integrity check\");\n            }\n          }\n\n          _this.localUri = localUri;\n        }\n\n        _this.downloaded = true;\n\n        _this.downloadCallbacks.forEach((_ref2) => {\n          var {\n            resolve\n          } = _ref2;\n          return resolve();\n        });\n      } catch (e) {\n        _this.downloadCallbacks.forEach((_ref3) => {\n          var {\n            reject\n          } = _ref3;\n          return reject(e);\n        });\n\n        throw e;\n      } finally {\n        _this.downloading = false;\n        _this.downloadCallbacks = [];\n      }\n    })();\n  }\n\n}\nAsset.byHash = {};\nAsset.byUri = {};\nresolveAssetSource.setCustomSourceTransformer(resolver => {\n  var asset = Asset.fromMetadata(resolver.asset);\n  return resolver.fromSource(asset.downloaded ? asset.localUri : asset.uri);\n});","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/expo-asset/src/Asset.js"],"names":["AssetRegistry","AssetSourceResolver","resolveAssetSource","uriparser","urljoin","FS","Constants","require","FileSystem","error","Error","default","parser","Parser","bundledAssets","Set","assetMapOverride","manifest","getManifestBaseUrl","manifestUrl","urlComponents","parse","protocol","relative","directory","format","manifestBaseUrl","experienceUrl","resolveIfRelative","uri","uriComponents","replace","isImageType","type","test","getExtension","url","filename","filenameFromUrl","dotIndex","lastIndexOf","substring","file","pickScale","originalMeta","meta","hash","scale","scales","length","PixelRatio","get","index","findIndex","s","fileHashes","fileUris","suffix","name","Platform","OS","assetUrlOverride","httpServerLocation","developer","bundleUrl","match","getUriInBundle","assetName","__DEV__","appOwnership","has","bundleDirectory","getImageInfoAsync","src","Promise","resolve","reject","img","Image","onerror","onload","title","localName","width","naturalWidth","height","naturalHeight","Asset","constructor","localUri","downloading","downloaded","downloadCallbacks","loadAsync","moduleId","moduleIds","all","map","m","fromModule","downloadAsync","virtualAssetModule","fromURI","getAssetByID","fromMetadata","metaHash","byHash","asset","byUri","indexOf","split","push","cacheDirectory","exists","md5","getInfoAsync","cache","forEach","e","setCustomSourceTransformer","resolver","fromSource"],"mappings":"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","sourcesContent":["import { PixelRatio, Platform } from 'react-native';\nimport AssetRegistry from 'react-native/Libraries/Image/AssetRegistry';\nimport AssetSourceResolver from 'react-native/Libraries/Image/AssetSourceResolver';\nimport resolveAssetSource from 'react-native/Libraries/Image/resolveAssetSource';\nimport uriparser from 'uri-parser';\nimport urljoin from 'url-join';\n\nlet FS, Constants;\n\ntry {\n  FS = require('expo-file-system').FileSystem;\n} catch (error) {\n  throw new Error('`expo-asset` requires `expo-file-system` package to be installed and linked.');\n}\n\ntry {\n  Constants = require('expo-constants').default;\n} catch (error) {\n  throw new Error('`expo-asset` requires `expo-constants` package to be installed and linked.');\n}\n\nconst parser = new uriparser.Parser();\n\n// Fast lookup check if assets are available in the local bundle.\nconst bundledAssets = new Set(FS.bundledAssets || []);\n\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = Constants.manifest && Constants.manifest.assetMapOverride;\n\n// get base url of manifest (ie) https://site.com\nconst getManifestBaseUrl = manifestUrl => {\n  const urlComponents = parser.parse(manifestUrl);\n\n  // change to http(s) if scheme is exp/exps\n  if (urlComponents.protocol === 'exp') {\n    urlComponents.protocol = 'http';\n  } else if (urlComponents.protocol === 'exps') {\n    urlComponents.protocol = 'https';\n  }\n\n  // trim file extension and query params, if any (ie) https://site.com/index.exp?s=q -> https://site.com\n  urlComponents.relative = urlComponents.directory;\n  return parser.format(urlComponents);\n};\n\n// compute manifest base url if available\nconst manifestBaseUrl = Constants.experienceUrl\n  ? getManifestBaseUrl(Constants.experienceUrl)\n  : null;\n\n// resolve against manifestBaseUrl if uri is relative\nconst resolveIfRelative = uri => {\n  const uriComponents = parser.parse(uri);\n  if (uriComponents.protocol === '' && manifestBaseUrl) {\n    // uri is relative (ie) ./assets, remove ./ prefix if exists\n    return urljoin(manifestBaseUrl, uri.replace(/^\\.?\\//, ''));\n  } else {\n    return uri;\n  }\n};\n\nfunction isImageType(type) {\n  return /^(jpeg|jpg|gif|png|bmp)$/i.test(type);\n}\n\nfunction getExtension(url) {\n  const filename = filenameFromUrl(url);\n  const dotIndex = filename.lastIndexOf('.');\n  // Ignore leading dots for hidden files\n  return dotIndex > 0 ? filename.substring(dotIndex) : '';\n}\n\nfunction filenameFromUrl(url) {\n  const urlComponents = parser.parse(this.uri);\n  return urlComponents.file;\n}\n\n// Return { uri, hash } for an asset's file, picking the correct scale, based on its React Native\n// metadata. If the asset isn't an image just picks the first file.\nconst pickScale = originalMeta => {\n  // Override with the asset map in manifest if available\n  const meta = assetMapOverride\n    ? { ...originalMeta, ...assetMapOverride[originalMeta.hash] }\n    : originalMeta;\n\n  // This logic is based on that in AssetSourceResolver.js, we just do it with our own tweaks for\n  // Expo\n  const scale =\n    meta.scales.length > 1 ? AssetSourceResolver.pickScale(meta.scales, PixelRatio.get()) : 1;\n  const index = meta.scales.findIndex(s => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n\n  const suffix =\n    '/' +\n    meta.name +\n    (scale === 1 ? '' : '@' + scale + 'x') +\n    '.' +\n    meta.type +\n    '?platform=' +\n    Platform.OS +\n    '&hash=' +\n    meta.hash;\n\n  // Allow asset processors to directly provide the URL that will be loaded\n  if (uri) {\n    return {\n      uri: resolveIfRelative(uri),\n      hash,\n    };\n  }\n\n  // Check if the assetUrl was overriden in the manifest\n  const assetUrlOverride = Constants.manifest && Constants.manifest.assetUrlOverride;\n  if (assetUrlOverride) {\n    return {\n      uri: resolveIfRelative(urljoin(assetUrlOverride, hash)),\n      hash,\n    };\n  }\n\n  if (/^https?:/.test(meta.httpServerLocation)) {\n    // This is a full URL, so we avoid prepending bundle URL/cloudfront\n    // This usually means Asset is on a different server, and the URL is present in the bundle\n    return {\n      uri: meta.httpServerLocation + suffix,\n      hash,\n    };\n  }\n\n  if (Constants.manifest && Constants.manifest.developer) {\n    // Development server URI is pieced together\n    return {\n      uri:\n        Constants.manifest.bundleUrl.match(/^https?:\\/\\/.*?\\//)[0] +\n        meta.httpServerLocation.replace(/^\\/?/, '') +\n        suffix,\n      hash,\n    };\n  }\n\n  // CDN URI is based directly on the hash\n  return {\n    uri: 'https://d1wp6m56sqw74a.cloudfront.net/~assets/' + hash,\n    hash,\n  };\n};\n\n// Returns the uri of an asset from its hash and type or null if the asset is\n// not included in the app bundle.\nconst getUriInBundle = (hash, type) => {\n  const assetName = 'asset_' + hash + (type ? '.' + type : '');\n  if (__DEV__ || Constants.appOwnership !== 'standalone' || !bundledAssets.has(assetName)) {\n    return null;\n  }\n  return `${FS.bundleDirectory}${assetName}`;\n};\n\nfunction getImageInfoAsync(src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onerror = reject;\n    img.onload = () => {\n      const name = img.name || img.title || img.localName;\n      resolve({\n        name,\n        width: img.naturalWidth,\n        height: img.naturalHeight,\n      });\n    };\n    img.src = src;\n  });\n}\nexport default class Asset {\n  static byHash = {};\n  static byUri = {};\n\n  constructor({ name, type, hash, uri, width, height }) {\n    this.name = name;\n    this.type = type;\n    this.hash = hash;\n    this.uri = uri;\n    this.localUri = getUriInBundle(hash, type);\n    if (typeof width === 'number') {\n      this.width = width;\n    }\n    if (typeof height === 'number') {\n      this.height = height;\n    }\n\n    this.downloading = false;\n    this.downloaded = !!this.localUri;\n    this.downloadCallbacks = [];\n  }\n\n  static loadAsync(moduleId) {\n    let moduleIds = typeof moduleId === 'number' ? [moduleId] : moduleId;\n    return Promise.all(moduleIds.map(m => Asset.fromModule(m).downloadAsync()));\n  }\n\n  static fromModule(virtualAssetModule) {\n    if (typeof virtualAssetModule === 'string') {\n      return Asset.fromURI(virtualAssetModule);\n    } else {\n      const meta = AssetRegistry.getAssetByID(virtualAssetModule);\n      return Asset.fromMetadata(meta);\n    }\n  }\n\n  static fromMetadata(meta) {\n    // The hash of the whole asset, not to confuse with the hash of a specific\n    // file returned from `pickScale`.\n    const metaHash = meta.hash;\n    if (Asset.byHash[metaHash]) {\n      return Asset.byHash[metaHash];\n    }\n\n    const { uri, hash } = pickScale(meta);\n\n    const asset = new Asset({\n      name: meta.name,\n      type: meta.type,\n      hash,\n      uri,\n      width: meta.width,\n      height: meta.height,\n    });\n    Asset.byHash[metaHash] = asset;\n    return asset;\n  }\n\n  static fromURI(uri) {\n    // Possibly Base64\n    if (Asset.byUri[uri]) {\n      return Asset.byUri[uri];\n    }\n\n    let type = '';\n    if (uri.indexOf(';base64') > -1) {\n      type = uri.split(';')[0].split('/')[1];\n    } else {\n      type = getExtension(uri);\n    }\n\n    const asset = new Asset({\n      type,\n      uri,\n    });\n\n    Asset.byUri[uri] = asset;\n\n    return asset;\n  }\n\n  async downloadAsync() {\n    if (this.downloaded) {\n      return;\n    }\n    if (this.downloading) {\n      await new Promise((resolve, reject) => this.downloadCallbacks.push({ resolve, reject }));\n      return;\n    }\n    this.downloading = true;\n\n    try {\n      if (Platform.OS === 'web') {\n        if (isImageType(this.type)) {\n          const { width, height, name } = await getImageInfoAsync(this.uri);\n          this.width = width;\n          this.height = height;\n          this.name = name;\n        } else {\n          this.name = filenameFromUrl(this.uri);\n        }\n        this.localUri = this.uri;\n      } else {\n        const localUri = `${FS.cacheDirectory}ExponentAsset-${this.hash}.${this.type}`;\n        let { exists, md5 } = await FS.getInfoAsync(localUri, {\n          cache: true,\n          md5: true,\n        });\n        if (!exists || md5 !== this.hash) {\n          ({ md5 } = await FS.downloadAsync(this.uri, localUri, {\n            cache: true,\n            md5: true,\n          }));\n          if (md5 !== this.hash) {\n            throw new Error(\n              `Downloaded file for asset '${this.name}.${this.type}' ` +\n                `Located at ${this.uri} ` +\n                `failed MD5 integrity check`\n            );\n          }\n        }\n\n        this.localUri = localUri;\n      }\n      this.downloaded = true;\n      this.downloadCallbacks.forEach(({ resolve }) => resolve());\n    } catch (e) {\n      this.downloadCallbacks.forEach(({ reject }) => reject(e));\n      throw e;\n    } finally {\n      this.downloading = false;\n      this.downloadCallbacks = [];\n    }\n  }\n}\n\n// Override React Native's asset resolution for `Image` components\nresolveAssetSource.setCustomSourceTransformer(resolver => {\n  const asset = Asset.fromMetadata(resolver.asset);\n  return resolver.fromSource(asset.downloaded ? asset.localUri : asset.uri);\n});\n"]},"metadata":{},"sourceType":"module"}