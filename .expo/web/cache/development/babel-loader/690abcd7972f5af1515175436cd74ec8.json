{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport invariant from 'invariant';\nimport { CameraType, ImageType } from \"./CameraModule.types\";\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from \"./constants\";\nexport function getImageSize(videoWidth, videoHeight, scale) {\n  var width = videoWidth * scale;\n  var ratio = videoWidth / width;\n  var height = videoHeight / ratio;\n  return {\n    width,\n    height\n  };\n}\nexport function toDataURL(canvas, imageType, quality) {\n  invariant(Object.values(ImageType).includes(imageType), \"expo-camera: \".concat(imageType, \" is not a valid ImageType. Expected a string from: \").concat(Object.values(ImageType).join(', ')));\n  var format = ImageTypeFormat[imageType];\n\n  if (imageType === ImageType.jpg) {\n    invariant(quality <= 1 && quality >= 0, \"expo-camera: \".concat(quality, \" is not a valid image quality. Expected a number from 0...1\"));\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\nexport function hasValidConstraints(preferredCameraType, width, height) {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCaptureOptions(config) {\n  var captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false\n  };\n\n  for (var key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n\n  return captureOptions;\n}\n\nvar DEFAULT_QUALITY = 0.92;\nexport function captureImage(video, pictureOptions) {\n  var config = ensureCaptureOptions(pictureOptions);\n  var {\n    scale,\n    imageType,\n    quality = DEFAULT_QUALITY,\n    isImageMirror\n  } = config;\n  var {\n    videoWidth,\n    videoHeight\n  } = video;\n  var {\n    width,\n    height\n  } = getImageSize(videoWidth, videoHeight, scale);\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  var context = canvas.getContext('2d');\n  if (!context) throw new Error('Context is not defined');\n\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n  var base64 = toDataURL(canvas, imageType, quality);\n  return base64;\n}\n\nfunction getUserMedia(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  } else {\n    var _getUserMedia = navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'];\n\n    return new Promise((resolve, reject) => _getUserMedia.call(navigator, constraints, resolve, reject));\n  }\n}\n\nfunction getSupportedConstraints() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n\n  return {};\n}\n\nexport function getIdealConstraints(preferredCameraType, width, height) {\n  var preferredConstraints = {\n    audio: false,\n    video: {}\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  var supports = getSupportedConstraints();\n\n  if (!supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    preferredConstraints.video.facingMode = {\n      ideal: CameraTypeToFacingMode[preferredCameraType]\n    };\n  }\n\n  preferredConstraints.video.width = width;\n  preferredConstraints.video.height = height;\n  return preferredConstraints;\n}\nexport function getStreamDevice(_x, _x2, _x3) {\n  return _getStreamDevice.apply(this, arguments);\n}\n\nfunction _getStreamDevice() {\n  _getStreamDevice = _asyncToGenerator(function* (preferredCameraType, preferredWidth, preferredHeight) {\n    var constraints = getIdealConstraints(preferredCameraType, preferredWidth, preferredHeight);\n    var stream = yield getUserMedia(constraints);\n    return stream;\n  });\n  return _getStreamDevice.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/CameraModule/CameraUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import invariant from 'invariant';\n\nimport { PictureOptions } from './../Camera.types';\nimport { CameraType, CaptureOptions, ImageSize, ImageType } from './CameraModule.types';\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from './constants';\n\ninterface ConstrainLongRange {\n  max?: number;\n  min?: number;\n  exact?: number;\n  ideal?: number;\n}\n\nexport function getImageSize(videoWidth: number, videoHeight: number, scale: number): ImageSize {\n  const width = videoWidth * scale;\n  const ratio = videoWidth / width;\n  const height = videoHeight / ratio;\n\n  return {\n    width,\n    height,\n  };\n}\n\nexport function toDataURL(\n  canvas: HTMLCanvasElement,\n  imageType: ImageType,\n  quality: number\n): string {\n  invariant(\n    Object.values(ImageType).includes(imageType),\n    `expo-camera: ${imageType} is not a valid ImageType. Expected a string from: ${Object.values(\n      ImageType\n    ).join(', ')}`\n  );\n\n  const format = ImageTypeFormat[imageType];\n  if (imageType === ImageType.jpg) {\n    invariant(\n      quality <= 1 && quality >= 0,\n      `expo-camera: ${quality} is not a valid image quality. Expected a number from 0...1`\n    );\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\n\nexport function hasValidConstraints(\n  preferredCameraType?: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): boolean {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCaptureOptions(config: any): CaptureOptions {\n  const captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false,\n  };\n\n  for (const key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n  return captureOptions;\n}\n\nconst DEFAULT_QUALITY = 0.92;\n\nexport function captureImage(video: HTMLVideoElement, pictureOptions: PictureOptions): string {\n  const config = ensureCaptureOptions(pictureOptions);\n  const { scale, imageType, quality = DEFAULT_QUALITY, isImageMirror } = config;\n\n  const { videoWidth, videoHeight } = video;\n  const { width, height } = getImageSize(videoWidth, videoHeight, scale);\n\n  // Build the canvas size and draw the camera image to the context from video\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d');\n\n  //TODO: Bacon: useless\n  if (!context) throw new Error('Context is not defined');\n  // Flip horizontally (as css transform: rotateY(180deg))\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n\n  const base64 = toDataURL(canvas, imageType, quality);\n  return base64;\n}\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  } else {\n    let _getUserMedia = navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'];\n    return new Promise((resolve, reject) =>\n      _getUserMedia.call(navigator, constraints, resolve, reject)\n    );\n  }\n}\n\nfunction getSupportedConstraints() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n  return {};\n}\n\nexport function getIdealConstraints(\n  preferredCameraType: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): MediaStreamConstraints {\n  let preferredConstraints: MediaStreamConstraints = {\n    audio: false,\n    video: {},\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  const supports = getSupportedConstraints();\n  if (!supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n      ideal: CameraTypeToFacingMode[preferredCameraType],\n      // exact: CameraTypeToFacingMode[preferredCameraType],\n    };\n  }\n\n  (preferredConstraints.video as MediaTrackConstraints).width = width;\n  (preferredConstraints.video as MediaTrackConstraints).height = height;\n\n  return preferredConstraints;\n}\n\nexport async function getStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = getIdealConstraints(\n    preferredCameraType,\n    preferredWidth,\n    preferredHeight\n  );\n  const stream: MediaStream = await getUserMedia(constraints);\n  return stream;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}