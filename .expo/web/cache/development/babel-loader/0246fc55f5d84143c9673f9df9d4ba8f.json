{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { EventEmitter } from '@unimodules/core';\n\nclass GeocoderError extends Error {\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n\n}\n\nvar emitter = new EventEmitter({});\n\nfunction positionToJSON(position) {\n  if (!position) return null;\n  var {\n    coords = {},\n    timestamp\n  } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed\n    },\n    timestamp\n  };\n}\n\nexport default {\n  get name() {\n    return 'ExpoLocation';\n  },\n\n  getProviderStatusAsync() {\n    return _asyncToGenerator(function* () {\n      return {\n        locationServicesEnabled: 'geolocation' in navigator\n      };\n    })();\n  },\n\n  getCurrentPositionAsync(options) {\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(position => resolve(positionToJSON(position)), reject, options));\n    })();\n  },\n\n  removeWatchAsync(watchId) {\n    return _asyncToGenerator(function* () {\n      navigator.geolocation.clearWatch(watchId);\n    })();\n  },\n\n  watchDeviceHeading(headingId) {\n    return _asyncToGenerator(function* () {\n      console.warn('Location.watchDeviceHeading: is not supported on web');\n    })();\n  },\n\n  hasServicesEnabledAsync() {\n    return _asyncToGenerator(function* () {\n      return 'geolocation' in navigator;\n    })();\n  },\n\n  geocodeAsync() {\n    return _asyncToGenerator(function* () {\n      throw new GeocoderError();\n    })();\n  },\n\n  reverseGeocodeAsync() {\n    return _asyncToGenerator(function* () {\n      throw new GeocoderError();\n    })();\n  },\n\n  watchPositionImplAsync(watchId, options) {\n    return _asyncToGenerator(function* () {\n      return new Promise(resolve => {\n        watchId = global.navigator.geolocation.watchPosition(location => {\n          emitter.emit('Expo.locationChanged', {\n            watchId,\n            location: positionToJSON(location)\n          });\n        }, null, options);\n        resolve(watchId);\n      });\n    })();\n  },\n\n  requestPermissionsAsync() {\n    return _asyncToGenerator(function* () {\n      return new Promise(resolve => {\n        navigator.geolocation.getCurrentPosition(() => resolve({\n          status: 'granted'\n        }), (_ref) => {\n          var {\n            code\n          } = _ref;\n\n          if (code === 1) {\n              resolve({\n                status: 'denied'\n              });\n            } else {\n            resolve({\n              status: 'undetermined'\n            });\n          }\n        });\n      });\n    })();\n  }\n\n};","map":{"version":3,"sources":["../src/ExpoLocation.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from '@unimodules/core';\n\ninterface Coordinates {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n  altitudeAccuracy?: number;\n  heading?: number;\n  speed?: number;\n}\n\ninterface Position {\n  coords: Coordinates;\n  timestamp: number;\n}\n\ninterface PermissionResult {\n  status: string;\n}\n\nclass GeocoderError extends Error {\n  code: string;\n\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\n\nconst emitter = new EventEmitter({} as any);\n\nfunction positionToJSON(position: any): Position | null {\n  if (!position) return null;\n\n  const { coords = {}, timestamp } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed,\n    },\n    timestamp,\n  };\n}\n\nexport default {\n  get name(): string {\n    return 'ExpoLocation';\n  },\n  async getProviderStatusAsync(): Promise<{ locationServicesEnabled: boolean }> {\n    return {\n      locationServicesEnabled: 'geolocation' in navigator,\n    };\n  },\n  async getCurrentPositionAsync(options: Object): Promise<Position | null> {\n    return new Promise<Position | null>((resolve, reject) =>\n      navigator.geolocation.getCurrentPosition(\n        position => resolve(positionToJSON(position)),\n        reject,\n        options\n      )\n    );\n  },\n  async removeWatchAsync(watchId): Promise<void> {\n    navigator.geolocation.clearWatch(watchId);\n  },\n  async watchDeviceHeading(headingId): Promise<void> {\n    console.warn('Location.watchDeviceHeading: is not supported on web');\n  },\n  async hasServicesEnabledAsync(): Promise<boolean> {\n    return 'geolocation' in navigator;\n  },\n  async geocodeAsync(): Promise<Array<any>> {\n    throw new GeocoderError();\n  },\n  async reverseGeocodeAsync(): Promise<Array<any>> {\n    throw new GeocoderError();\n  },\n  async watchPositionImplAsync(watchId: string, options: Object): Promise<string> {\n    return new Promise<string>(resolve => {\n      // @ts-ignore\n      watchId = global.navigator.geolocation.watchPosition(\n        location => {\n          emitter.emit('Expo.locationChanged', { watchId, location: positionToJSON(location) });\n        },\n        null,\n        options\n      );\n      resolve(watchId);\n    });\n  },\n  async requestPermissionsAsync(): Promise<PermissionResult> {\n    return new Promise<PermissionResult>(resolve => {\n      navigator.geolocation.getCurrentPosition(\n        () => resolve({ status: 'granted' }),\n        ({ code }) => {\n          if (code === 1 /* PERMISSION_DENIED */) {\n            resolve({ status: 'denied' });\n          } else {\n            resolve({ status: 'undetermined' });\n          }\n        }\n      );\n    });\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}