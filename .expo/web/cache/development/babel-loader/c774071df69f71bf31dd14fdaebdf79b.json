{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport ExpoLocalization from \"./ExpoLocalization\";\n\nvar parseLocale = locale => locale.replace('_', '-');\n\nexport var locale = parseLocale(ExpoLocalization.locale);\nexport var locales = ExpoLocalization.locales.map(parseLocale);\nexport var timezone = ExpoLocalization.timezone;\nexport var isoCurrencyCodes = ExpoLocalization.isoCurrencyCodes;\nexport var country = ExpoLocalization.country;\nexport var isRTL = ExpoLocalization.isRTL;\nexport function getLocalizationAsync() {\n  return _getLocalizationAsync.apply(this, arguments);\n}\n\nfunction _getLocalizationAsync() {\n  _getLocalizationAsync = _asyncToGenerator(function* () {\n    var _yield$ExpoLocalizati = yield ExpoLocalization.getLocalizationAsync(),\n        {\n      locale,\n      locales\n    } = _yield$ExpoLocalizati,\n        localization = _objectWithoutProperties(_yield$ExpoLocalizati, [\"locale\", \"locales\"]);\n\n    return _objectSpread({\n      locale: parseLocale(locale),\n      locales: ExpoLocalization.locales.map(parseLocale)\n    }, localization);\n  });\n  return _getLocalizationAsync.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/Localization.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,OAAO,gBAAP;;AAMA,IAAM,WAAW,GAAI,MAAD,IAA4B,MAAM,CAAC,OAAP,CAAe,GAAf,EAAoB,GAApB,CAAhD;;AAEA,OAAO,IAAM,MAAM,GAAG,WAAW,CAAC,gBAAgB,CAAC,MAAlB,CAA1B;AACP,OAAO,IAAM,OAAO,GAAG,gBAAgB,CAAC,OAAjB,CAAyB,GAAzB,CAA6B,WAA7B,CAAhB;AACP,OAAO,IAAM,QAAQ,GAAG,gBAAgB,CAAC,QAAlC;AACP,OAAO,IAAM,gBAAgB,GAAG,gBAAgB,CAAC,gBAA1C;AACP,OAAO,IAAM,OAAO,GAAG,gBAAgB,CAAC,OAAjC;AACP,OAAO,IAAM,KAAK,GAAG,gBAAgB,CAAC,KAA/B;AAEP,gBAAsB,oBAAtB;AAAA;AAAA;;;4CAAO,aAAmC;AACxC,sCAAmD,gBAAgB,CAAC,oBAAjB,EAAnD;AAAA,QAAM;AAAE,MAAA,MAAF;AAAU,MAAA;AAAV,KAAN;AAAA,QAA4B,YAA5B;;AACA;AACE,MAAA,MAAM,EAAE,WAAW,CAAC,MAAD,CADrB;AAEE,MAAA,OAAO,EAAE,gBAAgB,CAAC,OAAjB,CAAyB,GAAzB,CAA6B,WAA7B;AAFX,OAGK,YAHL;AAKD,G","sourcesContent":["import ExpoLocalization from './ExpoLocalization';\n\nimport { Localization } from './Localization.types';\n\n// Web, Android, and some iOS values use `-`. This will convert the iOS values that use `_`\n// https://github.com/expo/expo/blob/21ae94bae2e8369992050c433a00699d425b35bd/packages/expo/src/Localization.ts#L112-L114\nconst parseLocale = (locale: string): string => locale.replace('_', '-');\n\nexport const locale = parseLocale(ExpoLocalization.locale);\nexport const locales = ExpoLocalization.locales.map(parseLocale);\nexport const timezone = ExpoLocalization.timezone;\nexport const isoCurrencyCodes = ExpoLocalization.isoCurrencyCodes;\nexport const country = ExpoLocalization.country;\nexport const isRTL = ExpoLocalization.isRTL;\n\nexport async function getLocalizationAsync(): Promise<Localization> {\n  const { locale, locales, ...localization } = await ExpoLocalization.getLocalizationAsync();\n  return {\n    locale: parseLocale(locale),\n    locales: ExpoLocalization.locales.map(parseLocale),\n    ...localization,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}