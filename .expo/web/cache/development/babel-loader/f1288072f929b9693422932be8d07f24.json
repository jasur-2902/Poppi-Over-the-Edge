{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\jshukurov\\\\Desktop\\\\Poppi Over The Edge\\\\Poppi-Over-the-Edge-master\\\\node_modules\\\\react-native-reanimated\\\\src\\\\createAnimatedComponent.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport ReanimatedEventEmitter from \"./ReanimatedEventEmitter\";\nimport ViewStylePropTypes from 'react-native/Libraries/Components/View/ViewStylePropTypes';\nimport AnimatedEvent from \"./core/AnimatedEvent\";\nimport AnimatedNode from \"./core/AnimatedNode\";\nimport { createOrReusePropsNode } from \"./core/AnimatedProps\";\nimport invariant from 'fbjs/lib/invariant';\nvar NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  var component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n\n  class AnimatedComponent extends React.Component {\n    constructor() {\n      super(...arguments);\n      this._invokeAnimatedPropsCallbackOnMount = false;\n\n      this._animatedPropsCallback = () => {\n        if (this._component == null) {\n          this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (typeof this._component.setNativeProps !== 'function') {\n          this.forceUpdate();\n        } else {\n          this._component.setNativeProps(this._propsAnimated.__getValue());\n        }\n      };\n\n      this._setComponentRef = c => {\n        if (c !== this._component) {\n          this._component = c;\n        }\n      };\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n\n      this._propsAnimated && this._propsAnimated.__detach();\n\n      this._detachNativeEvents();\n    }\n\n    setNativeProps(props) {\n      this._component.setNativeProps(props);\n    }\n\n    componentWillMount() {\n      this._attachProps(this.props);\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n\n      this._attachNativeEvents();\n\n      this._attachPropUpdater();\n    }\n\n    _getEventViewRef() {\n      return this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n    }\n\n    _attachNativeEvents() {\n      var node = this._getEventViewRef();\n\n      for (var key in this.props) {\n        var prop = this.props[key];\n\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      var node = this._getEventViewRef();\n\n      for (var key in this.props) {\n        var prop = this.props[key];\n\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      var node = this._getEventViewRef();\n\n      var attached = new Set();\n      var nextEvts = new Set();\n\n      for (var key in this.props) {\n        var prop = this.props[key];\n\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        }\n      }\n\n      for (var _key in prevProps) {\n        var _prop = this.props[_key];\n\n        if (_prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(_prop.__nodeID)) {\n            _prop.detachEvent(node, _key);\n          } else {\n            attached.add(_prop.__nodeID);\n          }\n        }\n      }\n\n      for (var _key2 in this.props) {\n        var _prop2 = this.props[_key2];\n\n        if (_prop2 instanceof AnimatedEvent && !attached.has(_prop2.__nodeID)) {\n          _prop2.attachEvent(node, _key2);\n        }\n      }\n    }\n\n    _attachProps(nextProps) {\n      var oldPropsAnimated = this._propsAnimated;\n      this._propsAnimated = createOrReusePropsNode(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n\n      if (oldPropsAnimated !== this._propsAnimated) {\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      var viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _detachPropUpdater() {\n      var viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated.setNativeView(this._component);\n    }\n\n    _filterNonAnimatedStyle(inputStyle) {\n      var style = {};\n\n      for (var key in inputStyle) {\n        var value = inputStyle[key];\n\n        if (!(value instanceof AnimatedNode) && key !== 'transform') {\n          style[key] = value;\n        }\n      }\n\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      var props = {};\n\n      for (var key in inputProps) {\n        var value = inputProps[key];\n\n        if (key === 'style') {\n          props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        }\n      }\n\n      return props;\n    }\n\n    render() {\n      var props = this._filterNonAnimatedProps(this.props);\n\n      return React.createElement(Component, _extends({}, props, {\n        ref: this._setComponentRef,\n        collapsable: false,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 218,\n          columnNumber: 9\n        }\n      }));\n    }\n\n    getNode() {\n      return this._component;\n    }\n\n  }\n\n  var propTypes = Component.propTypes;\n  AnimatedComponent.propTypes = {\n    style: function style(props, propName, componentName) {\n      if (!propTypes) {\n        return;\n      }\n\n      for (var key in ViewStylePropTypes) {\n        if (!propTypes[key] && props[key] !== undefined) {\n          console.warn('You are setting the style `{ ' + key + ': ... }` as a prop. You ' + 'should nest it in a style object. ' + 'E.g. `{ style: { ' + key + ': ... } }`');\n        }\n      }\n    }\n  };\n  return AnimatedComponent;\n}","map":{"version":3,"sources":["C:/Users/jshukurov/Desktop/Poppi Over The Edge/Poppi-Over-the-Edge-master/node_modules/react-native-reanimated/src/createAnimatedComponent.js"],"names":["React","ReanimatedEventEmitter","ViewStylePropTypes","AnimatedEvent","AnimatedNode","createOrReusePropsNode","invariant","NODE_MAPPING","Map","listener","data","component","get","viewTag","_updateFromNative","props","createAnimatedComponent","Component","prototype","isReactComponent","AnimatedComponent","_invokeAnimatedPropsCallbackOnMount","_animatedPropsCallback","_component","setNativeProps","forceUpdate","_propsAnimated","__getValue","_setComponentRef","c","componentWillUnmount","_detachPropUpdater","__detach","_detachNativeEvents","componentWillMount","_attachProps","componentDidMount","setNativeView","_attachNativeEvents","_attachPropUpdater","_getEventViewRef","getScrollableNode","node","key","prop","attachEvent","detachEvent","_reattachNativeEvents","prevProps","attached","Set","nextEvts","add","__nodeID","has","nextProps","oldPropsAnimated","findNodeHandle","set","size","addListener","delete","removeAllListeners","componentDidUpdate","_filterNonAnimatedStyle","inputStyle","style","value","_filterNonAnimatedProps","inputProps","StyleSheet","flatten","render","getNode","propTypes","propName","componentName","undefined","console","warn"],"mappings":";;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;;;AAEA,OAAOC,sBAAP;AACA,OAAOC,kBAAP,MAA+B,2DAA/B;AAEA,OAAOC,aAAP;AACA,OAAOC,YAAP;AACA,SAASC,sBAAT;AAEA,OAAOC,SAAP,MAAsB,oBAAtB;AAEA,IAAMC,YAAY,GAAG,IAAIC,GAAJ,EAArB;;AAEA,SAASC,QAAT,CAAkBC,IAAlB,EAAwB;AACtB,MAAMC,SAAS,GAAGJ,YAAY,CAACK,GAAb,CAAiBF,IAAI,CAACG,OAAtB,CAAlB;AACAF,EAAAA,SAAS,IAAIA,SAAS,CAACG,iBAAV,CAA4BJ,IAAI,CAACK,KAAjC,CAAb;AACD;;AAED,eAAe,SAASC,uBAAT,CAAiCC,SAAjC,EAA4C;AACzDX,EAAAA,SAAS,CACP,OAAOW,SAAP,KAAqB,UAArB,IACGA,SAAS,CAACC,SAAV,IAAuBD,SAAS,CAACC,SAAV,CAAoBC,gBAFvC,EAGP,iFACE,gCAJK,CAAT;;AAOA,QAAMC,iBAAN,SAAgCpB,KAAK,CAACiB,SAAtC,CAAgD;AAAA;AAAA;AAAA,WAC9CI,mCAD8C,GACR,KADQ;;AAAA,WA8F9CC,sBA9F8C,GA8FrB,MAAM;AAC7B,YAAI,KAAKC,UAAL,IAAmB,IAAvB,EAA6B;AAM3B,eAAKF,mCAAL,GAA2C,IAA3C;AACD,SAPD,MAOO,IAAI,OAAO,KAAKE,UAAL,CAAgBC,cAAvB,KAA0C,UAA9C,EAA0D;AAC/D,eAAKC,WAAL;AACD,SAFM,MAEA;AACL,eAAKF,UAAL,CAAgBC,cAAhB,CAA+B,KAAKE,cAAL,CAAoBC,UAApB,EAA/B;AACD;AACF,OA3G6C;;AAAA,WA8J9CC,gBA9J8C,GA8J3BC,CAAC,IAAI;AACtB,YAAIA,CAAC,KAAK,KAAKN,UAAf,EAA2B;AACzB,eAAKA,UAAL,GAAkBM,CAAlB;AACD;AACF,OAlK6C;AAAA;;AAG9CC,IAAAA,oBAAoB,GAAG;AACrB,WAAKC,kBAAL;;AACA,WAAKL,cAAL,IAAuB,KAAKA,cAAL,CAAoBM,QAApB,EAAvB;;AACA,WAAKC,mBAAL;AACD;;AAEDT,IAAAA,cAAc,CAACT,KAAD,EAAQ;AACpB,WAAKQ,UAAL,CAAgBC,cAAhB,CAA+BT,KAA/B;AACD;;AAEDmB,IAAAA,kBAAkB,GAAG;AACnB,WAAKC,YAAL,CAAkB,KAAKpB,KAAvB;AACD;;AAEDqB,IAAAA,iBAAiB,GAAG;AAClB,UAAI,KAAKf,mCAAT,EAA8C;AAC5C,aAAKA,mCAAL,GAA2C,KAA3C;;AACA,aAAKC,sBAAL;AACD;;AAED,WAAKI,cAAL,CAAoBW,aAApB,CAAkC,KAAKd,UAAvC;;AACA,WAAKe,mBAAL;;AACA,WAAKC,kBAAL;AACD;;AAEDC,IAAAA,gBAAgB,GAAG;AAGjB,aAAO,KAAKjB,UAAL,CAAgBkB,iBAAhB,GACH,KAAKlB,UAAL,CAAgBkB,iBAAhB,EADG,GAEH,KAAKlB,UAFT;AAGD;;AAEDe,IAAAA,mBAAmB,GAAG;AACpB,UAAMI,IAAI,GAAG,KAAKF,gBAAL,EAAb;;AAEA,WAAK,IAAMG,GAAX,IAAkB,KAAK5B,KAAvB,EAA8B;AAC5B,YAAM6B,IAAI,GAAG,KAAK7B,KAAL,CAAW4B,GAAX,CAAb;;AACA,YAAIC,IAAI,YAAYzC,aAApB,EAAmC;AACjCyC,UAAAA,IAAI,CAACC,WAAL,CAAiBH,IAAjB,EAAuBC,GAAvB;AACD;AACF;AACF;;AAEDV,IAAAA,mBAAmB,GAAG;AACpB,UAAMS,IAAI,GAAG,KAAKF,gBAAL,EAAb;;AAEA,WAAK,IAAMG,GAAX,IAAkB,KAAK5B,KAAvB,EAA8B;AAC5B,YAAM6B,IAAI,GAAG,KAAK7B,KAAL,CAAW4B,GAAX,CAAb;;AACA,YAAIC,IAAI,YAAYzC,aAApB,EAAmC;AACjCyC,UAAAA,IAAI,CAACE,WAAL,CAAiBJ,IAAjB,EAAuBC,GAAvB;AACD;AACF;AACF;;AAEDI,IAAAA,qBAAqB,CAACC,SAAD,EAAY;AAC/B,UAAMN,IAAI,GAAG,KAAKF,gBAAL,EAAb;;AACA,UAAMS,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;AACA,UAAMC,QAAQ,GAAG,IAAID,GAAJ,EAAjB;;AACA,WAAK,IAAMP,GAAX,IAAkB,KAAK5B,KAAvB,EAA8B;AAC5B,YAAM6B,IAAI,GAAG,KAAK7B,KAAL,CAAW4B,GAAX,CAAb;;AACA,YAAIC,IAAI,YAAYzC,aAApB,EAAmC;AACjCgD,UAAAA,QAAQ,CAACC,GAAT,CAAaR,IAAI,CAACS,QAAlB;AACD;AACF;;AACD,WAAK,IAAMV,IAAX,IAAkBK,SAAlB,EAA6B;AAC3B,YAAMJ,KAAI,GAAG,KAAK7B,KAAL,CAAW4B,IAAX,CAAb;;AACA,YAAIC,KAAI,YAAYzC,aAApB,EAAmC;AACjC,cAAI,CAACgD,QAAQ,CAACG,GAAT,CAAaV,KAAI,CAACS,QAAlB,CAAL,EAAkC;AAEhCT,YAAAA,KAAI,CAACE,WAAL,CAAiBJ,IAAjB,EAAuBC,IAAvB;AACD,WAHD,MAGO;AAELM,YAAAA,QAAQ,CAACG,GAAT,CAAaR,KAAI,CAACS,QAAlB;AACD;AACF;AACF;;AACD,WAAK,IAAMV,KAAX,IAAkB,KAAK5B,KAAvB,EAA8B;AAC5B,YAAM6B,MAAI,GAAG,KAAK7B,KAAL,CAAW4B,KAAX,CAAb;;AACA,YAAIC,MAAI,YAAYzC,aAAhB,IAAiC,CAAC8C,QAAQ,CAACK,GAAT,CAAaV,MAAI,CAACS,QAAlB,CAAtC,EAAmE;AAEjET,UAAAA,MAAI,CAACC,WAAL,CAAiBH,IAAjB,EAAuBC,KAAvB;AACD;AACF;AACF;;AAsBDR,IAAAA,YAAY,CAACoB,SAAD,EAAY;AACtB,UAAMC,gBAAgB,GAAG,KAAK9B,cAA9B;AAEA,WAAKA,cAAL,GAAsBrB,sBAAsB,CAC1CkD,SAD0C,EAE1C,KAAKjC,sBAFqC,EAG1CkC,gBAH0C,CAA5C;;AAMA,UAAIA,gBAAgB,KAAK,KAAK9B,cAA9B,EAA8C;AAS5C8B,QAAAA,gBAAgB,IAAIA,gBAAgB,CAACxB,QAAjB,EAApB;AACD;AACF;;AAEDlB,IAAAA,iBAAiB,CAACC,KAAD,EAAQ;AACvB,WAAKQ,UAAL,CAAgBC,cAAhB,CAA+BT,KAA/B;AACD;;AAEDwB,IAAAA,kBAAkB,GAAG;AACnB,UAAM1B,OAAO,GAAG4C,cAAc,CAAC,IAAD,CAA9B;AACAlD,MAAAA,YAAY,CAACmD,GAAb,CAAiB7C,OAAjB,EAA0B,IAA1B;;AACA,UAAIN,YAAY,CAACoD,IAAb,KAAsB,CAA1B,EAA6B;AAC3B1D,QAAAA,sBAAsB,CAAC2D,WAAvB,CAAmC,yBAAnC,EAA8DnD,QAA9D;AACD;AACF;;AAEDsB,IAAAA,kBAAkB,GAAG;AACnB,UAAMlB,OAAO,GAAG4C,cAAc,CAAC,IAAD,CAA9B;AACAlD,MAAAA,YAAY,CAACsD,MAAb,CAAoBhD,OAApB;;AACA,UAAIN,YAAY,CAACoD,IAAb,KAAsB,CAA1B,EAA6B;AAC3B1D,QAAAA,sBAAsB,CAAC6D,kBAAvB,CAA0C,yBAA1C;AACD;AACF;;AAEDC,IAAAA,kBAAkB,CAACf,SAAD,EAAY;AAC5B,WAAKb,YAAL,CAAkB,KAAKpB,KAAvB;;AACA,WAAKgC,qBAAL,CAA2BC,SAA3B;;AAEA,WAAKtB,cAAL,CAAoBW,aAApB,CAAkC,KAAKd,UAAvC;AACD;;AAQDyC,IAAAA,uBAAuB,CAACC,UAAD,EAAa;AAClC,UAAMC,KAAK,GAAG,EAAd;;AACA,WAAK,IAAMvB,GAAX,IAAkBsB,UAAlB,EAA8B;AAC5B,YAAME,KAAK,GAAGF,UAAU,CAACtB,GAAD,CAAxB;;AACA,YAAI,EAAEwB,KAAK,YAAY/D,YAAnB,KAAoCuC,GAAG,KAAK,WAAhD,EAA6D;AAC3DuB,UAAAA,KAAK,CAACvB,GAAD,CAAL,GAAawB,KAAb;AACD;AACF;;AACD,aAAOD,KAAP;AACD;;AAEDE,IAAAA,uBAAuB,CAACC,UAAD,EAAa;AAClC,UAAMtD,KAAK,GAAG,EAAd;;AACA,WAAK,IAAM4B,GAAX,IAAkB0B,UAAlB,EAA8B;AAC5B,YAAMF,KAAK,GAAGE,UAAU,CAAC1B,GAAD,CAAxB;;AACA,YAAIA,GAAG,KAAK,OAAZ,EAAqB;AACnB5B,UAAAA,KAAK,CAAC4B,GAAD,CAAL,GAAa,KAAKqB,uBAAL,CAA6BM,UAAU,CAACC,OAAX,CAAmBJ,KAAnB,CAA7B,CAAb;AACD,SAFD,MAEO,IAAI,EAAEA,KAAK,YAAY/D,YAAnB,CAAJ,EAAsC;AAC3CW,UAAAA,KAAK,CAAC4B,GAAD,CAAL,GAAawB,KAAb;AACD;AACF;;AACD,aAAOpD,KAAP;AACD;;AAEDyD,IAAAA,MAAM,GAAG;AACP,UAAMzD,KAAK,GAAG,KAAKqD,uBAAL,CAA6B,KAAKrD,KAAlC,CAAd;;AACA,aACE,oBAAC,SAAD,eAAeA,KAAf;AAAsB,QAAA,GAAG,EAAE,KAAKa,gBAAhC;AAAkD,QAAA,WAAW,EAAE,KAA/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SADF;AAGD;;AAID6C,IAAAA,OAAO,GAAG;AACR,aAAO,KAAKlD,UAAZ;AACD;;AAvM6C;;AA0MhD,MAAMmD,SAAS,GAAGzD,SAAS,CAACyD,SAA5B;AAEAtD,EAAAA,iBAAiB,CAACsD,SAAlB,GAA8B;AAC5BR,IAAAA,KAAK,EAAE,eAASnD,KAAT,EAAgB4D,QAAhB,EAA0BC,aAA1B,EAAyC;AAC9C,UAAI,CAACF,SAAL,EAAgB;AACd;AACD;;AAED,WAAK,IAAM/B,GAAX,IAAkBzC,kBAAlB,EAAsC;AACpC,YAAI,CAACwE,SAAS,CAAC/B,GAAD,CAAV,IAAmB5B,KAAK,CAAC4B,GAAD,CAAL,KAAekC,SAAtC,EAAiD;AAC/CC,UAAAA,OAAO,CAACC,IAAR,CACE,kCACEpC,GADF,GAEE,0BAFF,GAGE,oCAHF,GAIE,mBAJF,GAKEA,GALF,GAME,YAPJ;AASD;AACF;AACF;AAnB2B,GAA9B;AAsBA,SAAOvB,iBAAP;AACD","sourcesContent":["import React from 'react';\nimport { findNodeHandle, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\nimport ViewStylePropTypes from 'react-native/Libraries/Components/View/ViewStylePropTypes';\n\nimport AnimatedEvent from './core/AnimatedEvent';\nimport AnimatedNode from './core/AnimatedNode';\nimport { createOrReusePropsNode } from './core/AnimatedProps';\n\nimport invariant from 'fbjs/lib/invariant';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    setNativeProps(props) {\n      this._component.setNativeProps(props);\n    }\n\n    componentWillMount() {\n      this._attachProps(this.props);\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        }\n      }\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = c => {\n      if (c !== this._component) {\n        this._component = c;\n      }\n    };\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (!(value instanceof AnimatedNode) && key !== 'transform') {\n          style[key] = value;\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      return (\n        <Component {...props} ref={this._setComponentRef} collapsable={false} />\n      );\n    }\n\n    // A third party library can use getNode()\n    // to get the node reference of the decorated component\n    getNode() {\n      return this._component;\n    }\n  }\n\n  const propTypes = Component.propTypes;\n\n  AnimatedComponent.propTypes = {\n    style: function(props, propName, componentName) {\n      if (!propTypes) {\n        return;\n      }\n\n      for (const key in ViewStylePropTypes) {\n        if (!propTypes[key] && props[key] !== undefined) {\n          console.warn(\n            'You are setting the style `{ ' +\n              key +\n              ': ... }` as a prop. You ' +\n              'should nest it in a style object. ' +\n              'E.g. `{ style: { ' +\n              key +\n              ': ... } }`'\n          );\n        }\n      }\n    },\n  };\n\n  return AnimatedComponent;\n}\n"]},"metadata":{},"sourceType":"module"}