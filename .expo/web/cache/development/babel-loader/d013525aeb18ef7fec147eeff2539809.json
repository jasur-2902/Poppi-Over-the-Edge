{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { UnavailabilityError } from '@unimodules/core';\nimport ExpoGoogleSignIn from \"./ExpoGoogleSignIn\";\nimport GoogleAuthentication from \"./GoogleAuthentication\";\nimport GoogleIdentity from \"./GoogleIdentity\";\n\nclass GoogleUser extends GoogleIdentity {\n  constructor(options) {\n    var _this;\n\n    super(options);\n    _this = this;\n    this.clearCache = _asyncToGenerator(function* () {\n      if (!ExpoGoogleSignIn.clearCacheAsync) {\n        return;\n      }\n\n      if (!_this.auth || !_this.auth.accessToken) {\n        throw new Error('GoogleSignIn: GoogleUser.clearCache(): Invalid accessToken');\n      }\n\n      return yield ExpoGoogleSignIn.clearCacheAsync({\n        token: _this.auth.accessToken\n      });\n    });\n\n    this.getHeaders = () => {\n      if (!this.auth || !this.auth.accessToken || !this.auth.accessToken.length) {\n        throw new Error('GoogleSignIn: GoogleUser.getHeaders(): Invalid accessToken');\n      }\n\n      return {\n        Authorization: \"Bearer \".concat(this.auth.accessToken),\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      };\n    };\n\n    this.refreshAuth = _asyncToGenerator(function* () {\n      if (!ExpoGoogleSignIn.getTokensAsync) {\n        throw new UnavailabilityError('GoogleSignIn', 'getTokensAsync');\n      }\n\n      var response = yield ExpoGoogleSignIn.getTokensAsync(false);\n\n      if (response.idToken == null && _this.auth) {\n        response.idToken = _this.auth.idToken;\n      }\n\n      if (!_this.auth) {\n        _this.auth = new GoogleAuthentication(response);\n      } else {\n        _this.auth.idToken = response.idToken;\n        _this.auth.accessToken = response.accessToken;\n      }\n\n      return _this.auth;\n    });\n    var {\n      auth,\n      scopes,\n      hostedDomain,\n      serverAuthCode\n    } = options;\n    this.auth = auth;\n    this.scopes = scopes;\n    this.hostedDomain = hostedDomain;\n    this.serverAuthCode = serverAuthCode;\n  }\n\n  equals(other) {\n    if (!super.equals(other) || !(other instanceof GoogleUser)) {\n      return false;\n    }\n\n    if (this.auth != null) {\n      return this.auth.equals(other.auth) && this.scopes === other.scopes && this.hostedDomain === other.hostedDomain && this.serverAuthCode === other.serverAuthCode;\n    } else {\n      return other.auth == null;\n    }\n  }\n\n  toJSON() {\n    var auth = this.auth;\n\n    if (this.auth && this.auth.toJSON) {\n      auth = this.auth.toJSON();\n    }\n\n    return _objectSpread({}, super.toJSON(), {\n      auth,\n      scopes: this.scopes,\n      hostedDomain: this.hostedDomain,\n      serverAuthCode: this.serverAuthCode\n    });\n  }\n\n}\n\nexport default GoogleUser;","map":{"version":3,"sources":["../src/GoogleUser.ts"],"names":[],"mappings":"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","sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\nimport invariant from 'invariant';\n\nimport ExpoGoogleSignIn from './ExpoGoogleSignIn';\nimport GoogleAuthentication from './GoogleAuthentication';\nimport GoogleIdentity from './GoogleIdentity';\n\nclass GoogleUser extends GoogleIdentity {\n  auth: GoogleAuthentication | null;\n  scopes: string[];\n  hostedDomain?: string;\n  serverAuthCode?: string;\n\n  constructor(options) {\n    super(options);\n    const { auth, scopes, hostedDomain, serverAuthCode } = options;\n\n    this.auth = auth;\n    this.scopes = scopes;\n    this.hostedDomain = hostedDomain;\n    this.serverAuthCode = serverAuthCode;\n  }\n\n  clearCache = async () => {\n    if (!ExpoGoogleSignIn.clearCacheAsync) {\n      return;\n    }\n    if (!this.auth || !this.auth.accessToken) {\n      throw new Error('GoogleSignIn: GoogleUser.clearCache(): Invalid accessToken');\n    }\n    return await ExpoGoogleSignIn.clearCacheAsync({ token: this.auth.accessToken });\n  };\n\n  getHeaders = (): {\n    [key: string]: string;\n  } => {\n    if (!this.auth || !this.auth.accessToken || !this.auth.accessToken.length) {\n      throw new Error('GoogleSignIn: GoogleUser.getHeaders(): Invalid accessToken');\n    }\n    return {\n      Authorization: `Bearer ${this.auth.accessToken}`,\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    };\n  };\n\n  refreshAuth = async (): Promise<GoogleAuthentication | null> => {\n    if (!ExpoGoogleSignIn.getTokensAsync) {\n      throw new UnavailabilityError('GoogleSignIn', 'getTokensAsync');\n    }\n    const response: {\n      idToken?: string;\n      accessToken?: string;\n      auth?: {\n        accessToken?: string;\n      };\n    } = await ExpoGoogleSignIn.getTokensAsync(false);\n    if (response.idToken == null && this.auth) {\n      response.idToken = this.auth.idToken;\n    }\n    if (!this.auth) {\n      this.auth = new GoogleAuthentication(response);\n    } else {\n      this.auth.idToken = response.idToken;\n      this.auth.accessToken = response.accessToken;\n    }\n    return this.auth;\n  };\n\n  equals(other: any): boolean {\n    if (!super.equals(other) || !(other instanceof GoogleUser)) {\n      return false;\n    }\n\n    if (this.auth != null) {\n      return (\n        this.auth.equals(other.auth) &&\n        this.scopes === other.scopes &&\n        this.hostedDomain === other.hostedDomain &&\n        this.serverAuthCode === other.serverAuthCode\n      );\n    } else {\n      return other.auth == null;\n    }\n  }\n\n  toJSON(): { [key: string]: any } {\n    let auth: any = this.auth;\n    if (this.auth && this.auth.toJSON) {\n      auth = this.auth.toJSON();\n    }\n\n    return {\n      ...super.toJSON(),\n      auth,\n      scopes: this.scopes,\n      hostedDomain: this.hostedDomain,\n      serverAuthCode: this.serverAuthCode,\n    };\n  }\n}\n\nexport default GoogleUser;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}